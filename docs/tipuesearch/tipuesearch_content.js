var tipuesearch = {"pages":[{"title":" Libpq-Fortran ","text":"Libpq-Fortran Libpq-Fortran is a Modern Fortran interface to the PostgreSQL libpq C library . This does not contain the libpq library; only the wrapper is included. The source of this package is available on GitHub - shinobuamasaki/libpq-fortran . Features Current Supported compilers are: GNU Compiler Collection: gfortran , Intel oneAPI Fortran Compiler ifx , Fortran Compiler Classic ifort . Supported PostgreSQL version: PostgreSQL v15.4 (libpq v5.15) Connections: Connection via DSN (data source name) Connection via PostgreSQL connection string UTF-8 client encoding Build This package is managed by Fortran Package Manager ( fpm ). The libpq is required and you may need to add the path to the directory containing libpq-fe.h to the environment variable FPM_CFLAGS . Add to fpm.toml in your project: [build] link = [ \"pq\" ] [dependencies] libpq-fortran = { git = \"https://github.com/shinobuamasaki/libpq-fortran\" } Test This package is tested on the following environments: FreeBSD (Release 13.2, gfortran v13.1.0) Gentoo Linux ( gfortran v12.3.1, ifort 2021.9.0, ifx 2023.1.0) Ubuntu 22.04 LTS ( gfortran v11.4.0) Microsoft Windows 10 ( gfortran MinGW-W64 v13.1.0) Goals Note that below does not represent the current state of this package. Libpq-Fortran aims to wrap libpq as documented in the PostgreSQL documentation, including all non-deprecated functionallity with its explicit interfaces . Non-Goals This package will not: parse SQL, emit SQL, provide an interface handling transactions or cursors, provide abstractions over common SQL patterns. Licenses libpq Source and PostgreSQL Documentation Portions Copyright © 1996-2023, The PostgreSQL Global Development Group Portions Copyright © 1994, The Regents of the University of California Permission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose, without fee, and without a written agreement is\nhereby granted, provided that the above copyright notice and this\nparagraph and the following two paragraphs appear in all copies. IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR\nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\nDOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\nON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO\nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. Everything Else The license for the remainder of this package appears in LICENSE . Acknowledgement The creation of this package was inspired by a discussion in the Fortran-jp community. Developer Info Amasaki Shinobu","tags":"home","loc":"index.html"},{"title":"PQconninfoOption – Libpq-Fortran ","text":"type, public :: PQconninfoOption Contents Variables keyword envvar compiled val label dispchar dispsize Components Type Visibility Attributes Name Initial character(len=CONNINFO_LABEL_LEN), public :: keyword character(len=CONNINFO_LABEL_LEN), public :: envvar character(len=CONNINFO_LABEL_LEN), public :: compiled character(len=CONNINFO_LABEL_LEN), public :: val character(len=CONNINFO_LABEL_LEN), public :: label character(len=1), public :: dispchar integer(kind=int32), public :: dispsize","tags":"","loc":"type/pqconninfooption.html"},{"title":"c_PQconninfoOption – Libpq-Fortran ","text":"type, public :: c_PQconninfoOption Contents Variables keyword envvar compiled val label dispchar dispsize Components Type Visibility Attributes Name Initial type(c_ptr), public :: keyword type(c_ptr), public :: envvar type(c_ptr), public :: compiled type(c_ptr), public :: val type(c_ptr), public :: label type(c_ptr), public :: dispchar integer(kind=c_int), public :: dispsize","tags":"","loc":"type/c_pqconninfooption.html"},{"title":"c_PQconnOptionSizes – Libpq-Fortran ","text":"type, public :: c_PQconnOptionSizes Contents Variables keyword envvar compiled val label dispchar Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: keyword integer(kind=c_int), public :: envvar integer(kind=c_int), public :: compiled integer(kind=c_int), public :: val integer(kind=c_int), public :: label integer(kind=c_int), public :: dispchar","tags":"","loc":"type/c_pqconnoptionsizes.html"},{"title":"pgNotify – Libpq-Fortran ","text":"type, public, bind(c) :: pgNotify Contents Variables relname be_pid extra Components Type Visibility Attributes Name Initial type(c_ptr), public :: relname integer(kind=c_int), public :: be_pid type(c_ptr), public :: extra","tags":"","loc":"type/pgnotify.html"},{"title":"max_length_char_array – Libpq-Fortran","text":"public  function max_length_char_array(array) result(res) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Return Value integer(kind=int32) Contents","tags":"","loc":"proc/max_length_char_array.html"},{"title":"c_to_f_charpointer – Libpq-Fortran","text":"public  function c_to_f_charpointer(char_cptr) result(res) Uses iso_c_binding Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: char_cptr Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/c_to_f_charpointer.html"},{"title":"c_to_f_charpointer_with_length – Libpq-Fortran","text":"public  function c_to_f_charpointer_with_length(char_cptr, length) result(res) Uses iso_c_binding iso_fortran_env Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: char_cptr integer(kind=int32) :: length Return Value character(kind=c_char, len=length), pointer Contents","tags":"","loc":"proc/c_to_f_charpointer_with_length.html"},{"title":"convert_cptr – Libpq-Fortran","text":"public  function convert_cptr(cptr, length) result(fptr) Uses iso_c_binding Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cptr integer(kind=c_size_t), intent(in) :: length Return Value character(kind=c_char, len=length), pointer Contents","tags":"","loc":"proc/convert_cptr.html"},{"title":"cchar_array_from_strings – Libpq-Fortran","text":"public  subroutine cchar_array_from_strings(words, c_words, max_length) Uses iso_c_binding iso_fortran_env Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words (:) character(kind=c_char, len=max_length+1), intent(out), allocatable, target :: c_words (:) integer(kind=int32), intent(in) :: max_length Contents","tags":"","loc":"proc/cchar_array_from_strings.html"},{"title":"cchar_array_from_strings_no_null – Libpq-Fortran","text":"public  subroutine cchar_array_from_strings_no_null(words, c_words, max_length) Uses iso_c_binding iso_fortran_env Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words (:) character(kind=c_char, len=max_length+1), intent(out), allocatable, target :: c_words (:) integer(kind=int32), intent(in) :: max_length Contents","tags":"","loc":"proc/cchar_array_from_strings_no_null.html"},{"title":"cptr_array_from_cchar – Libpq-Fortran","text":"public  subroutine cptr_array_from_cchar(c_words, ptr_array) Uses iso_c_binding Arguments Type Intent Optional Attributes Name character(kind=c_char, len=*), intent(in), target :: c_words (:) type(c_ptr), intent(out), allocatable :: ptr_array (:) Contents","tags":"","loc":"proc/cptr_array_from_cchar.html"},{"title":"cptr_array_from_cchar_no_null – Libpq-Fortran","text":"public  subroutine cptr_array_from_cchar_no_null(c_words, ptr_array) Uses iso_c_binding Arguments Type Intent Optional Attributes Name character(kind=c_char, len=*), intent(in), target :: c_words (:) type(c_ptr), intent(out), allocatable :: ptr_array (:) Contents","tags":"","loc":"proc/cptr_array_from_cchar_no_null.html"},{"title":"read_option – Libpq-Fortran","text":"public  subroutine read_option(sizes, c_option, option) Uses PQconninfoOption_t iso_c_binding Arguments Type Intent Optional Attributes Name type( c_PQconnOptionSizes ), intent(in) :: sizes type( c_PQconninfoOption ), intent(inout) :: c_option type( PQconninfoOption ), intent(out) :: option Contents","tags":"","loc":"proc/read_option.html"},{"title":"c_char_to_f_string – Libpq-Fortran","text":"public  subroutine c_char_to_f_string(cptr, str) Uses iso_c_binding iso_fortran_env Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cptr character(len=:), intent(out), allocatable :: str Contents","tags":"","loc":"proc/c_char_to_f_string.html"},{"title":"PQconnectdb – Libpq-Fortran","text":"public  function PQconnectdb(conninfo) result(conn) Uses iso_c_binding Connect to the database server with the provided connection string conninfo . Example character (:), allocatable :: conninfo type ( c_ptr ) :: conn conninfo = \"host=localhost user=postgres dbname=postgres password=foobar\" conn = PQcoonectdb ( conninfo ) ! Error handling if ( PQstatus ( conn ) /= CONNECTION_OK ) then print * , PQerrorMessage ( conn ) end if cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo PostgreSQL connection string Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqconnectdb.html"},{"title":"PQconnectdbParams – Libpq-Fortran","text":"public  function PQconnectdbParams(keywords, values, expand_dbname) result(conn) Uses iso_c_binding Connect to the database server with connection infomation provided as pairs of keywords and values arrays. Example character ( 16 ) :: keywords ( 3 ), values ( 3 ) type ( c_ptr ) :: conn keywords ( 1 ) = 'host' ; values ( 1 ) = 'localhost' keywords ( 2 ) = 'user' ; values ( 2 ) = 'postgres' keywords ( 3 ) = 'dbname' ; values ( 3 ) = 'postgres' conn = PQconnectdbParams ( keywords , values , 0 ) ! Error handling if ( PQstatus ( conn ) /= CONNECTION_OK ) then print * , PQerrorMessage ( conn ) end if cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: keywords (:) Keywords, such as host , hostaddr , dbname , user , password , etc. character(len=*), intent(in) :: values (:) The array of each value corresponding to that keyword. integer :: expand_dbname Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqconnectdbparams.html"},{"title":"PQsetdbLogin – Libpq-Fortran","text":"public  function PQsetdbLogin(host, port, options, tty, dbName, login, pwd) result(conn) Uses iso_c_binding Connect to the database server with connection infomation provided as each argument Example type ( c_ptr ) :: conn conn = PQsetdbLogin ( \"localhost\" , \"5432\" , \"\" , \"\" , \"postgres\" , \"postgres\" , \"\" ) ! Error handling if ( PQstatus ( conn ) /= CONNECTION_OK ) then print * , PQerrorMessage ( conn ) end if cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: host Hostname character(len=*), intent(in) :: port Port number character(len=*), intent(in) :: options Options character(len=*), intent(in) :: tty Empty string character(len=*), intent(in) :: dbName The name of the database character(len=*), intent(in) :: login The user name at this login character(len=*), intent(in) :: pwd The password of the user Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqsetdblogin.html"},{"title":"PQconnectStartParams – Libpq-Fortran","text":"public  function PQconnectStartParams(keywords, values, expand_dbname) result(conn) Uses iso_c_binding Connect to the database server in a nonblocking manner. Example type ( c_ptr ) :: conn integer :: res = - 1 character ( 16 ) :: keywords ( 3 ), values ( 3 ) type ( c_ptr ) :: conn keywords ( 1 ) = 'host' ; values ( 1 ) = 'localhost' keywords ( 2 ) = 'user' ; values ( 2 ) = 'postgres' keywords ( 3 ) = 'dbname' ; values ( 3 ) = 'postgres' conn = PQconnectStartParams ( keywords , values , 0 ) if ( c_associated ( conn )) then do while ( res /= PGRES_POLLING_OK ) ! loop for polling res = PQconnectPoll ( conn ) select case ( res ) case ( PGRES_POLLING_FAILED ) print * , PQerrorMessage ( conn ) error stop case ( PGRES_POLLING_OK ) print * , \"CONNECTION ESTABLISHED\" exit case default continue ! write some process here! end select end do else print * , \"Cannot connect the server.\" error stop end if References cf. PQconnectStart , PQconnectPoll cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: keywords (:) character(len=*), intent(in) :: values (:) integer :: expand_dbname Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqconnectstartparams.html"},{"title":"PQconnectStart – Libpq-Fortran","text":"public  function PQconnectStart(conninfo) result(conn) Uses iso_c_binding Connect to the database server in a nonblocking manner. Example character (:), allocatable :: conninfo type ( c_ptr ) :: conn integer :: res = - 1 conninfo = \"host=localhost user=postgres dbname=postgres\" conn = PQconnectStart ( conninfo ) if ( c_associated ( conn )) then do while ( res /= PGRES_POLLING_OK ) ! loop for polling res = PQconnectPoll ( conn ) select case ( res ) case ( PGRES_POLLING_FAILED ) print * , PQerrorMessage ( conn ) error stop case ( PGRES_POLLING_OK ) print * , \"CONNECTION ESTABLISHED\" exit case default continue ! write some process here! end select end do else print * , \"Cannot connect the server.\" error stop end if References cf. PQconnectPoll , PQconnectStartParams cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqconnectstart.html"},{"title":"PQconnectPoll – Libpq-Fortran","text":"public  function PQconnectPoll(conn) Uses iso_c_binding iso_fortran_env Connect to the database server in a nonblocking manner. References cf. PQconnectStart , PQconnectStartParams cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqconnectpoll.html"},{"title":"PQresetStart – Libpq-Fortran","text":"public  function PQresetStart(conn) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqresetstart.html"},{"title":"PQresetPoll – Libpq-Fortran","text":"public  function PQresetPoll(conn) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqresetpoll.html"},{"title":"PQpingParams – Libpq-Fortran","text":"public  function PQpingParams(keywords, values, expand_dbname) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: keywords (:) character(len=*), intent(in) :: values (:) integer, intent(in) :: expand_dbname Return Value integer(kind=c_int) Contents","tags":"","loc":"proc/pqpingparams.html"},{"title":"PQping – Libpq-Fortran","text":"public  function PQping(conninfo) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqping.html"},{"title":"PQdb – Libpq-Fortran","text":"public  function PQdb(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqdb.html"},{"title":"PQuser – Libpq-Fortran","text":"public  function PQuser(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pquser.html"},{"title":"PQpass – Libpq-Fortran","text":"public  function PQpass(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqpass.html"},{"title":"PQhost – Libpq-Fortran","text":"public  function PQhost(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqhost.html"},{"title":"PQhostaddr – Libpq-Fortran","text":"public  function PQhostaddr(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqhostaddr.html"},{"title":"PQport – Libpq-Fortran","text":"public  function PQport(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqport.html"},{"title":"PQoptions – Libpq-Fortran","text":"public  function PQoptions(conn) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqoptions.html"},{"title":"PQstatus – Libpq-Fortran","text":"public  function PQstatus(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqstatus.html"},{"title":"PQtransactionStatus – Libpq-Fortran","text":"public  function PQtransactionStatus(conn) result(res) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=c_int) Contents","tags":"","loc":"proc/pqtransactionstatus.html"},{"title":"PQparameterStatus – Libpq-Fortran","text":"public  function PQparameterStatus(conn, paramName) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: paramName Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqparameterstatus.html"},{"title":"PQprotocolVersion – Libpq-Fortran","text":"public  function PQprotocolVersion(conn) result(res) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer Contents","tags":"","loc":"proc/pqprotocolversion.html"},{"title":"PQserverVersion – Libpq-Fortran","text":"public  function PQserverVersion(conn) result(res) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer Contents","tags":"","loc":"proc/pqserverversion.html"},{"title":"PQerrorMessage – Libpq-Fortran","text":"public  function PQerrorMessage(conn) result(PQerrormessage) Uses iso_c_binding character_operations_m Returns the error message most recently generated by an operation on the connection. Nearly all libpq functions will set a message for PQerrorMessage if they fail. \nNote that by libpq convention, a nonempty PQerrorMessage result can consist of multiple lines,\nand will include a trailing newline. The caller should not free the result directly. \nIt will be freed when the associated PGconn handle is passed to PQfinish . \nThe result string should not be expected to remain the same across operations on the PGconn structure. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/pqerrormessage.html"},{"title":"PQsocket – Libpq-Fortran","text":"public  function PQsocket(conn) Uses iso_c_binding Obtain the file descriptor number of the connection socket to the server. A valid descriptor will be greater than or equal to 0; a result of -1 indicates that no server connection is\ncurrently open. (This will not change during normal operation, but could change during connection set up or \nreset.) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=c_int) Contents","tags":"","loc":"proc/pqsocket.html"},{"title":"PQbackendPID – Libpq-Fortran","text":"public  function PQbackendPID(conn) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=c_int) Contents","tags":"","loc":"proc/pqbackendpid.html"},{"title":"PQconnectionNeedsPassword – Libpq-Fortran","text":"public  function PQconnectionNeedsPassword(conn) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqconnectionneedspassword.html"},{"title":"PQconnectionUsedPassword – Libpq-Fortran","text":"public  function PQconnectionUsedPassword(conn) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqconnectionusedpassword.html"},{"title":"PQsslInUse – Libpq-Fortran","text":"public  function PQsslInUse(conn) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value logical Contents","tags":"","loc":"proc/pqsslinuse.html"},{"title":"PQgetCancel – Libpq-Fortran","text":"public  function PQgetCancel(conn) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqgetcancel.html"},{"title":"PQcancel – Libpq-Fortran","text":"public  function PQcancel(cancel, errbuf, errbufsize) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cancel character(len=*), intent(inout) :: errbuf integer(kind=int32), intent(in) :: errbufsize Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqcancel.html"},{"title":"PQclientEncoding – Libpq-Fortran","text":"public  function PQclientEncoding(conn) result(res) Uses iso_fortran_env iso_c_binding fe_exec_m character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqclientencoding.html"},{"title":"PQsetClientEncoding – Libpq-Fortran","text":"public  function PQsetClientEncoding(conn, encoding) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: encoding Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsetclientencoding.html"},{"title":"PQsetErrorVerbosity – Libpq-Fortran","text":"public  function PQsetErrorVerbosity(conn, verbosity) result(res) Uses iso_c_binding iso_fortran_env enumerators_t cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: verbosity Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqseterrorverbosity.html"},{"title":"PQsetErrorContextVisibility – Libpq-Fortran","text":"public  function PQsetErrorContextVisibility(conn, show_context) result(res) Uses iso_c_binding iso_fortran_env enumerators_t cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: show_context Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqseterrorcontextvisibility.html"},{"title":"PQconndefaults – Libpq-Fortran","text":"public  subroutine PQconndefaults(options) Uses PQconninfoOption_t iso_c_binding character_operations_m Get the default connection options. Example type ( PQconninfoOption ), allocatable , target :: options (:) integer :: i call PQconndefaults ( options ) ! Print the entire default options separated by colons do i = 1 , size ( options ) print '(12a, i0)' , trim ( options ( i )% keyword ), \" : \" , & trim ( options ( i )% envvar ), \" : \" , & trim ( options ( i )% compiled ), \" : \" , & trim ( options ( i )% val ), \" : \" , & trim ( options ( i )% label ), \" : \" , & trim ( options ( i )% dispchar ), \" : \" , & options ( i )% dispsize end do cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type( PQconninfoOption ), intent(out), dimension(:), allocatable, target :: options Contents","tags":"","loc":"proc/pqconndefaults.html"},{"title":"PQconninfo – Libpq-Fortran","text":"public  subroutine PQconninfo(conn, options) Uses PQconninfoOption_t iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn type( PQconninfoOption ), intent(out), dimension(:), allocatable, target :: options Contents","tags":"","loc":"proc/pqconninfo.html"},{"title":"PQconninfoParse – Libpq-Fortran","text":"public  subroutine PQconninfoParse(conninfo, options, errmsg, errflag) Uses PQconninfoOption_t iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo type( PQconninfoOption ), intent(out), dimension(:), allocatable, target :: options character(len=*), intent(out) :: errmsg logical :: errflag Contents","tags":"","loc":"proc/pqconninfoparse.html"},{"title":"PQfinish – Libpq-Fortran","text":"public  subroutine PQfinish(conn) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: conn Contents","tags":"","loc":"proc/pqfinish.html"},{"title":"PQreset – Libpq-Fortran","text":"public  subroutine PQreset(conn) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: conn Contents","tags":"","loc":"proc/pqreset.html"},{"title":"PQsslAttribute – Libpq-Fortran","text":"public  subroutine PQsslAttribute(conn, attribute_name, resultstr) Uses iso_c_binding iso_fortran_env character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: attribute_name character(len=:), allocatable :: resultstr Contents","tags":"","loc":"proc/pqsslattribute.html"},{"title":"PQsslAttributeNames – Libpq-Fortran","text":"public  subroutine PQsslAttributeNames(conn, strings, len) Uses iso_c_binding iso_fortran_env character_operations_m Subroutine for retrieving SSL attribute names from a PostgreSQL \n database connection and populating an array. Bug This doesn't work in the GCC 11.4.0 environment. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=len), allocatable :: strings (:) integer(kind=int32), intent(in) :: len Contents","tags":"","loc":"proc/pqsslattributenames.html"},{"title":"PQfreeCancel – Libpq-Fortran","text":"public  subroutine PQfreeCancel(cancel) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cancel Contents","tags":"","loc":"proc/pqfreecancel.html"},{"title":"PQencryptPasswordConn – Libpq-Fortran","text":"public  subroutine PQencryptPasswordConn(conn, passwd, user, algorithm, encrypted) Uses iso_fortran_env iso_c_binding fe_exec_m character_operations_m Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: passwd character(len=*), intent(in) :: user character(len=*), intent(in) :: algorithm character(len=*), intent(out) :: encrypted Contents","tags":"","loc":"proc/pqencryptpasswordconn.html"},{"title":"PQlibVersion – Libpq-Fortran","text":"public  function PQlibVersion() Uses iso_c_binding Get the current running version of libpq.\ncf. PostgreSQL Documentation Arguments None Return Value integer Contents None","tags":"","loc":"proc/pqlibversion.html"},{"title":"PQexec – Libpq-Fortran","text":"public  function PQexec(conn, query) result(res) Uses iso_c_binding Send query to the server and wait until receiving the result. Submit a command to the server and waits for the result. Returns a PGresult pointer or possibly a null pointer.\nA non-null pointer will generally be returned except in out-of-memory conditions or\nserious errors such as inability to send the command to the server.\nThe PQresultStatus function should be called to check the return value for any errors\n(including the value of a null pointer, in which case it will return PGRES_FATAL_ERROR).\nUse PQerrorMessage to get more information about such errors. cf. PostgreSQL Documentation Example type ( c_ptr ) :: conn , res integer :: stat conn = PQconnectdb ( \"dbname=postgres\" ) !...error handling... res = PQexec ( conn , \"select 1234;\" ) stat = PQresultStatus ( res ) if ( stat /= PGRES_COMMAND_OK . and . stat /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) call PQclear ( res ) call PQfinish ( conn ) error stop end if ! ... some statements ... call PQclear ( res ) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: query Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqexec.html"},{"title":"PQexecPrepared – Libpq-Fortran","text":"public  function PQexecPrepared(conn, stmtName, nParams, paramValues) result(res) Uses iso_c_binding iso_fortran_env character_operations_m Sends a request to execute a prepared statement with given parameters, and waits for the result. PQexecPrepared is like PQexecParam , but the command to be executed is spcified by\nnaming a previously-prepared statement, instead of giving a query string. This feature allows \ncommands that will be used repeated to be parsed and planned just once, rather than each\ntime they are executed. The statement must have been prepared previously in the current session. The parameters are identical to PQexecParams , except that the name of a prepared statement\nis given instead of a query string, and the paramTypes parameter is not present (it is not\nneeded since the prepared statement's parameter types were determined when it was created). cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName integer(kind=int32), intent(in) :: nParams character(len=*), intent(in) :: paramValues (:) Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqexecprepared.html"},{"title":"PQdescribePrepared – Libpq-Fortran","text":"public  function PQdescribePrepared(conn, stmtName) result(res) Uses iso_c_binding iso_fortran_env Submits a request to obtain information about the specified prepared statement, and waits for completion. PQdescribePrepared allows an application to obtain information about a previously prepared statement. stmtName can be \"\" to reference the unnamed statement, otherwise it must be the name of an existing\nprepared statement. On success, a PGresult with status PGRES_COMMAND_OK is returned. The PQnparams and PQparamtype can be applied to this PGresult to obtain information about the parameters of the\nprepared statement, and the functions PQnfields , PQfname , PQftype etc. provide information\nabout the result columns (if any) of the statement. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqdescribeprepared.html"},{"title":"PQdescribePortal – Libpq-Fortran","text":"public  function PQdescribePortal(conn, portalName) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: portalName Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqdescribeportal.html"},{"title":"PQresultStatus – Libpq-Fortran","text":"public  function PQresultStatus(pgresult) result(res) Uses iso_c_binding iso_fortran_env Returns the result status of the command. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqresultstatus.html"},{"title":"PQresStatus – Libpq-Fortran","text":"public  function PQresStatus(status) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: status Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqresstatus.html"},{"title":"PQresultErrorMessage – Libpq-Fortran","text":"public  function PQresultErrorMessage(pgresult) result(res) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/pqresulterrormessage.html"},{"title":"PQresultVerboseErrorMessage – Libpq-Fortran","text":"public  function PQresultVerboseErrorMessage(pgresult, verbosity, show_context) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: verbosity integer(kind=int32), intent(in) :: show_context Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/pqresultverboseerrormessage.html"},{"title":"PQresultErrorField – Libpq-Fortran","text":"public  function PQresultErrorField(pgresult, fieldcode) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: fieldcode Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/pqresulterrorfield.html"},{"title":"PQntuples – Libpq-Fortran","text":"public  function PQntuples(pgresult) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqntuples.html"},{"title":"PQnfields – Libpq-Fortran","text":"public  function PQnfields(pgresult) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqnfields.html"},{"title":"PQfname – Libpq-Fortran","text":"public  function PQfname(pgresult, field_num) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: field_num Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/pqfname.html"},{"title":"PQfnumber – Libpq-Fortran","text":"public  function PQfnumber(pgresult, column_name) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult character(len=*), intent(in) :: column_name Return Value integer Contents","tags":"","loc":"proc/pqfnumber.html"},{"title":"PQftable – Libpq-Fortran","text":"public  function PQftable(pgresult, column_number) result(res) Uses unsigned iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int64) Contents","tags":"","loc":"proc/pqftable.html"},{"title":"PQftablecol – Libpq-Fortran","text":"public  function PQftablecol(pgresult, column_number) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqftablecol.html"},{"title":"PQfformat – Libpq-Fortran","text":"public  function PQfformat(pgresult, column_number) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqfformat.html"},{"title":"PQftype – Libpq-Fortran","text":"public  function PQftype(pgresult, column_number) result(res) Uses unsigned iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int64) Contents","tags":"","loc":"proc/pqftype.html"},{"title":"PQfmod – Libpq-Fortran","text":"public  function PQfmod(pgresult, column_number) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqfmod.html"},{"title":"PQfsize – Libpq-Fortran","text":"public  function PQfsize(pgresult, column_number) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqfsize.html"},{"title":"PQbinaryTuples – Libpq-Fortran","text":"public  function PQbinaryTuples(pgresult) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value logical Contents","tags":"","loc":"proc/pqbinarytuples.html"},{"title":"PQgetvalue – Libpq-Fortran","text":"public  function PQgetvalue(pgresult, tuple_num, field_num) Uses iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=c_int), intent(in) :: tuple_num integer(kind=c_int), intent(in) :: field_num Return Value character(kind=c_char, len=:), pointer Contents","tags":"","loc":"proc/pqgetvalue.html"},{"title":"PQgetisnull – Libpq-Fortran","text":"public  function PQgetisnull(pgresult, row_number, column_number) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: row_number integer(kind=int32), intent(in) :: column_number Return Value logical Contents","tags":"","loc":"proc/pqgetisnull.html"},{"title":"PQgetlength – Libpq-Fortran","text":"public  function PQgetlength(pgresult) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqgetlength.html"},{"title":"PQnparams – Libpq-Fortran","text":"public  function PQnparams(pgresult) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqnparams.html"},{"title":"PQparamtype – Libpq-Fortran","text":"public  function PQparamtype(pgresult, param_number) result(res) Uses unsigned iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: param_number Return Value integer(kind=int64) Contents","tags":"","loc":"proc/pqparamtype.html"},{"title":"PQcmdStatus – Libpq-Fortran","text":"public  function PQcmdStatus(pgresult) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqcmdstatus.html"},{"title":"PQcmdTuples – Libpq-Fortran","text":"public  function PQcmdTuples(pgresult) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqcmdtuples.html"},{"title":"PQoidValue – Libpq-Fortran","text":"public  function PQoidValue(pgresult) result(res) Uses unsigned iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int64) Contents","tags":"","loc":"proc/pqoidvalue.html"},{"title":"PQescapeLiteral – Libpq-Fortran","text":"public  function PQescapeLiteral(conn, str, length, errmsg) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: str integer(kind=c_size_t), intent(in) :: length character(len=*), intent(inout), optional :: errmsg Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqescapeliteral.html"},{"title":"PQescapeIdentifier – Libpq-Fortran","text":"public  function PQescapeIdentifier(conn, str, length, errmsg) result(res) Uses iso_fortran_env iso_c_binding character_operations_m cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: str integer(kind=c_size_t), intent(in) :: length character(len=*), intent(inout), optional :: errmsg Return Value character(len=:), pointer Contents","tags":"","loc":"proc/pqescapeidentifier.html"},{"title":"PQsendQuery – Libpq-Fortran","text":"public  function PQsendQuery(conn, command) result(res) Uses iso_c_binding iso_fortran_env Submits a command to the server without waiting for the result(s). 1 is returned if the command was successfully dispatched and 0 if not (in which case, use PQerrorMessage to get more information about the failure). After successfully calling PQsendQuery , call PQgetResult one or more times\nto obtain the results. PQsendQuery cannot be called again (on the same connection)\nuntil PQgetResult has returned a null pointer, indicating that the command is done. In pipeline mode, this function is disallowed. cf. PostgreSQL Documentation Example type ( c_ptr ) :: conn type ( c_ptr ) :: res character (:), allocatable :: command integer :: ires conn = PQconnectdb ( \"dbname=postgres\" ) (... error handling ...) ires = PQsendQuery ( conn , command ) if ( ires /= 1 ) then print * , PQerrorMessage ( conn ) end if res = PQgetResult ( conn ) do while ( c_associated ( res )) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) end if print * , PQgetvalue ( res , 0 , 0 ) call PQclear ( res ) res = PQgetResult ( conn ) end do Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: command Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsendquery.html"},{"title":"PQsendDescribePrepared – Libpq-Fortran","text":"public  function PQsendDescribePrepared(conn, stmtName) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsenddescribeprepared.html"},{"title":"PQsendDescribePortal – Libpq-Fortran","text":"public  function PQsendDescribePortal(conn, portalName) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: portalName Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsenddescribeportal.html"},{"title":"PQgetResult – Libpq-Fortran","text":"public  function PQgetResult(conn) result(res) Uses iso_c_binding iso_fortran_env Waits for the next result from a prior PQsendQuery , PQsendQueryParams , PQsendPrepare , PQsendQueryPrepared , PQsendDescribePrepared , PQsendDescribePortra , or PQpipelineSync call,\nand returns it.  A null pointer is returned when the command is complete and there will be no more results. PQgetResult must be called repeatedly until it returns a null pointer, indicating that the command is done.\n(If called when no command is active, PQgetResult will just return a null pointer at once.)\nEach non-null result from PQgetResult should be processed using  the same PGresult accessor functions\nprebiously described. Don't forget to free each result object with PQclear when done with it.\nNote that PQgetResult will block only if a command is active and the necessary response data has not yet\nbeen read by PQconsumeInput . In pipeline mode, PQgetResult will return normally unless an error occurs; for any subsequent query sent\nafter the one that caused the error unit (and excluding) the next synchronization point, a special result of \ntype PGRES_PIPELINE_ABORTED will be returned, and a null pointer will be returned after it.\nWhen the pipeline synchronization point is reached, a result of type PGRES_PIPELINE_SYNC will be returned.\nThe result of the next query after the synchronization point follows immediately (that is, no null pointer\nis returned after the synchronization point). cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqgetresult.html"},{"title":"PQconsumeInput – Libpq-Fortran","text":"public  function PQconsumeInput(conn) result(res) Uses iso_c_binding iso_fortran_env If input is available from the server, consume it. PQconsumeInput normally returns 1 indicating \"no error\", but returns 0 if there was some kind of \ntrouble (in which case PQerrorMessage can be consulted). Note that the result does not say whether any\ninput data was actually collected. After calling PQconsumeInput , the application can check PQisBusy and/or PQnotifies to see if their state has changed. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqconsumeinput.html"},{"title":"PQisBusy – Libpq-Fortran","text":"public  function PQisBusy(conn) result(isBusy) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value logical Contents","tags":"","loc":"proc/pqisbusy.html"},{"title":"PQsetnonblocking – Libpq-Fortran","text":"public  function PQsetnonblocking(conn, arg) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: arg Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsetnonblocking.html"},{"title":"PQisnonblocking – Libpq-Fortran","text":"public  function PQisnonblocking(conn) result(isNonblocking) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value logical Contents","tags":"","loc":"proc/pqisnonblocking.html"},{"title":"PQflush – Libpq-Fortran","text":"public  function PQflush(conn) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqflush.html"},{"title":"PQpipelineStatus – Libpq-Fortran","text":"public  function PQpipelineStatus(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqpipelinestatus.html"},{"title":"PQenterPipelineMode – Libpq-Fortran","text":"public  function PQenterPipelineMode(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqenterpipelinemode.html"},{"title":"PQexitPipelineMode – Libpq-Fortran","text":"public  function PQexitPipelineMode(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqexitpipelinemode.html"},{"title":"PQpipelineSync – Libpq-Fortran","text":"public  function PQpipelineSync(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqpipelinesync.html"},{"title":"PQsendFlushRequest – Libpq-Fortran","text":"public  function PQsendFlushRequest(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsendflushrequest.html"},{"title":"PQsetSingleRowMode – Libpq-Fortran","text":"public  function PQsetSingleRowMode(conn) result(res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) Contents","tags":"","loc":"proc/pqsetsinglerowmode.html"},{"title":"PQnotifies – Libpq-Fortran","text":"public  function PQnotifies(conn) result(res) Uses iso_c_binding iso_fortran_env Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqnotifies.html"},{"title":"PQmakeEmptyPGresult – Libpq-Fortran","text":"public  function PQmakeEmptyPGresult(conn, status) result(res) Uses iso_fortran_env iso_c_binding enumerators_t cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: status Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqmakeemptypgresult.html"},{"title":"PQcopyResult – Libpq-Fortran","text":"public  function PQcopyResult(conn, res) Uses iso_c_binding iso_fortran_env cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn type(c_ptr), intent(in) :: res Return Value type(c_ptr) Contents","tags":"","loc":"proc/pqcopyresult.html"},{"title":"PQisthreadsafe – Libpq-Fortran","text":"public  function PQisthreadsafe() Uses iso_c_binding Get the threadsafety status of the current running libpq library.\ncf. PostgreSQL Documentation Arguments None Return Value logical Contents None","tags":"","loc":"proc/pqisthreadsafe.html"},{"title":"PQclear – Libpq-Fortran","text":"public  subroutine PQclear(res) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: res Contents","tags":"","loc":"proc/pqclear.html"},{"title":"PQfreemem – Libpq-Fortran","text":"public  subroutine PQfreemem(cptr) Uses iso_c_binding cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cptr Contents","tags":"","loc":"proc/pqfreemem.html"},{"title":"PQexecParams – Libpq-Fortran","text":"public interface PQexecParams Contents Module Procedures PQexecParams_int32 PQexecParams_int64 Module Procedures private  function PQexecParams_int32(conn, command, nParams, paramTypes, paramValues) result(res) Submits a command to the server and waits for the result, with the ability to pass \nparameters separately from the SQL command text. PQexecParams is like PQexec but offers additional functionality:\nparameter values can be specified separately from the command string proper, and query results\ncan be requested in text or binary format. cf. PostgreSQL Documentation Note Binary format have not been implemented yet. Example block character (:), allocatable :: command character ( 8 ) :: values ( 2 ) type ( c_ptr ) :: res command = \"select $1::bigint + $2::bigint;\" values ( 1 ) = \"300\" values ( 2 ) = \"500\" res = PQexecParams ( conn , command , size ( values ), [ 0 , 0 ], values ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) call PQclear ( res ) end if print * , PQgetvalue ( res , 0 , 0 ) ! the result \"800\" is expected. call PQclear ( res ) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn The connection object to send the command through. character(len=*), intent(in) :: command The SQL command string to be executed. If parameters are used, \nthey are referred to in the command string as $1 , $2 , etc. integer(kind=int32), intent(in) :: nParams The number of parameters supplied; it is the length of the arrays paramTypes , paramValues . integer(kind=int32), intent(in) :: paramTypes (:) Specifies, by OID, the data types to be assigned to the parameter symbols.\nIf any particular element in the array is zero, the server infers a data type\nfor the parameter symbol in the same way it would do for an untyped literal string. character(len=*), intent(in) :: paramValues (:) Specifies the actual values of the parameters. A empty string in this array means\nthe corresponding parameter is null. Return Value type(c_ptr) private  function PQexecParams_int64(conn, command, nParams, paramTypes, paramValues) result(res) Submits a command to the server and waits for the result, with the ability to pass \nparameters separately from the SQL command text. PQexecParams is like PQexec but offers additional functionality:\nparameter values can be specified separately from the command string proper, and query results\ncan be requested in text or binary format. cf. PostgreSQL Documentation Note Binary format have not been implemented yet. Example block character (:), allocatable :: command character ( 8 ) :: values ( 2 ) type ( c_ptr ) :: res command = \"select $1::bigint + $2::bigint;\" values ( 1 ) = \"300\" values ( 2 ) = \"500\" res = PQexecParams ( conn , command , size ( values ), [ 0_8 , 0_8 ], values ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) call PQclear ( res ) end if print * , PQgetvalue ( res , 0 , 0 ) ! the result \"800\" is expected. call PQclear ( res ) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn The connection object to send the command through. character(len=*), intent(in) :: command The SQL command string to be executed. If parameters are used, \nthey are referred to in the command string as $1 , $2 , etc. integer(kind=int32), intent(in) :: nParams The number of parameters supplied; it is the length of the arrays paramTypes , paramValues . integer(kind=int64), intent(in) :: paramTypes (:) Specifies, by OID, the data types to be assigned to the parameter symbols.\nIf any particular element in the array is zero, the server infers a data type\nfor the parameter symbol in the same way it would do for an untyped literal string. character(len=*), intent(in) :: paramValues (:) Specifies the actual values of the parameters. A empty string in this array means\nthe corresponding parameter is null. Return Value type(c_ptr)","tags":"","loc":"interface/pqexecparams.html"},{"title":"PQprepare – Libpq-Fortran","text":"public interface PQprepare Contents Module Procedures PQprepare_int32 PQprepare_int64 Module Procedures private  function PQprepare_int32(conn, stmtName, query, nParams, paramTypes) result(res) Submits a request to create a prepared statement with the given parameters, and waits for completion. PQprepare creates a prepared statement for later execution with PQexecPrepared .\nThis feature allows commands to be executed repeatedly without being parsed and\nplanned each time; see PREPARE for details. The function create a prepared statement named stmtName from the query string, which\nmust contain a single SQL command. stmtName can be \"\" to create an unnamed statement,\nin which case any pre-existing unnamed statement is automatically replaced; otherwise it is\nan error if the statement name is already defined in the current session. If any parameters are used, \nthey are referred to in the as $1 , $2 , etc. nParams is the number of parameters for which types\nare pre-specified in the array paramTypes . paramTypes specifies, by OID, the data types to be assigned to the parameter symbols. \nIf any particuler element in the paramTypes array is zero, the server assigns a data type to the\nparameter symbol in the same way it would do for an untyped literal string. \nAlso, the query can use parameter symbols with the numbers higher than nParams ; data types will \nbe inferred for these symbols as well. \n (See PQdescribePrepared ) for a means to find out what data types were inffered.) As with [[PQexec]] , the result is normally a PGresult object whose contents indicate server-side\nsuccess or failure. A null result indicates out-of-memory or inability to send to the command at all.\nUse PQerrorMessage to get more information about such errors. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int32), intent(in) :: paramTypes (:) Return Value type(c_ptr) private  function PQprepare_int64(conn, stmtName, query, nParams, paramTypes) result(res) Submits a request to create a prepared statement with the given parameters, and waits for completion. PQprepare creates a prepared statement for later execution with PQexecPrepared .\nThis feature allows commands to be executed repeatedly without being parsed and\nplanned each time; see PREPARE for details. The function create a prepared statement named stmtName from the query string, which\nmust contain a single SQL command. stmtName can be \"\" to create an unnamed statement,\nin which case any pre-existing unnamed statement is automatically replaced; otherwise it is\nan error if the statement name is already defined in the current session. If any parameters are used, \nthey are referred to in the as $1 , $2 , etc. nParams is the number of parameters for which types\nare pre-specified in the array paramTypes . paramTypes specifies, by OID, the data types to be assigned to the parameter symbols. \nIf any particuler element in the paramTypes array is zero, the server assigns a data type to the\nparameter symbol in the same way it would do for an untyped literal string. \nAlso, the query can use parameter symbols with the numbers higher than nParams ; data types will \nbe inferred for these symbols as well. As with PQexec , the result is normally a PGresult object whose contents indicate server-side\nsuccess or failure. A null result indicates out-of-memory or inability to send to the command at all.\nUse PQerrorMessage to get more information about such errors. cf. PostgreSQL Documentation cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int64), intent(in) :: paramTypes (:) Return Value type(c_ptr)","tags":"","loc":"interface/pqprepare.html"},{"title":"PQsendPrepare – Libpq-Fortran","text":"public interface PQsendPrepare Contents Module Procedures PQsendPrepare_int32 PQsendPrepare_int64 Module Procedures private  function PQsendPrepare_int32(conn, stmtName, query, nParams, paramTypes) result(res) Sends a request to create a prepared statement with the given parameters, without waiting for completion. This is an asynchronous version of PQprepare :\nit returns 1 if it was able to dispatch the request, and 0 if not.\nAfter a successfull call, call PQgetResult to determine whether the server successfully created the prepared statement. \nThe function's parameters are handled identically to PQprepare . cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int32), intent(in) :: paramTypes (:) Return Value integer(kind=int32) private  function PQsendPrepare_int64(conn, stmtName, query, nParams, paramTypes) result(res) Sends a request to create a prepared statement with the given parameters, without waiting for completion. This is an asynchronous version of PQprepare :\nit returns 1 if it was able to dispatch the request, and 0 if not.\nAfter a successfull call, call PQgetResult to determine whether the server successfully created the prepared statement. \nThe function's parameters are handled identically to PQprepare . cf. PostgreSQL Documentation cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int64), intent(in) :: paramTypes (:) Return Value integer(kind=int32)","tags":"","loc":"interface/pqsendprepare.html"},{"title":"PQsendQueryPrepared – Libpq-Fortran","text":"public interface PQsendQueryPrepared Contents Module Procedures PQsendQueryPrepared_text Module Procedures private  function PQsendQueryPrepared_text(conn, stmtName, nParams, paramValues) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName integer(kind=int32), intent(in) :: nParams character(len=*), intent(in) :: paramValues (:) Return Value integer(kind=int32)","tags":"","loc":"interface/pqsendqueryprepared.html"},{"title":"PQsendQueryParams – Libpq-Fortran","text":"public interface PQsendQueryParams Contents Module Procedures PQsendQueryParams_int32 PQsendQueryParams_int64 Module Procedures private  function PQsendQueryParams_int32(conn, command, nParams, paramTypes, paramValues) result(res) Submit a command and separate parameter to the server without waiting for the result(s).\nThis is equivalent to PQsendQuery , except that query parameters can be specified\nseparately form the query string. \nThis function's parameters are handled identically PQexecParams .\nLike PQexecParams , it allows only one command in the query. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: command integer(kind=int32), intent(in) :: nParams integer(kind=int32), intent(in) :: paramTypes (:) character(len=*), intent(in) :: paramValues (:) Return Value integer(kind=int32) private  function PQsendQueryParams_int64(conn, command, nParams, paramTypes, paramValues) result(res) Submit a command and separate parameter to the server without waiting for the result(s).\nThis is equivalent to PQsendQuery , \nexcept that query parameters can be specified\nseparately form the query string. \nThis function's parameters are handled identically PQexecParams .\nLike PQexecParams , it allows only one command in the query. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: command integer(kind=int32), intent(in) :: nParams integer(kind=int64), intent(in) :: paramTypes (:) character(len=*), intent(in) :: paramValues (:) Return Value integer(kind=int32)","tags":"","loc":"interface/pqsendqueryparams.html"},{"title":"error_message_fields_m – Libpq-Fortran","text":"Uses iso_fortran_env Contents Variables PG_DIAG_SEVERITY PG_DIAG_SEVERITY_NONLOCALIZED PG_DIAG_SQLSTATE PG_DIAG_MESSAGE_PRIMARY PG_DIAG_MESSAGE_DETAIL PG_DIAG_MESSAGE_HINT PG_DIAG_STATEMENT_POSITION PG_DIAG_INTERNAL_POSITION PG_DIAG_INTERNAL_QUERY PG_DIAG_CONTEXT PG_DIAG_SCHEMA_NAME PG_DIAG_TABLE_NAME PG_DIAG_COLUMN_NAME PG_DIAG_DATATYPE_NAME PG_DIAG_CONSTRAINT_NAME PG_DIAG_SOURCE_FILE PG_DIAG_SOURCE_LINE PG_DIAG_SOURCE_FUNCTION Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: PG_DIAG_SEVERITY = ichar('S') integer(kind=int32), public, parameter :: PG_DIAG_SEVERITY_NONLOCALIZED = ichar('V') integer(kind=int32), public, parameter :: PG_DIAG_SQLSTATE = ichar('C') integer(kind=int32), public, parameter :: PG_DIAG_MESSAGE_PRIMARY = ichar('M') integer(kind=int32), public, parameter :: PG_DIAG_MESSAGE_DETAIL = ichar('D') integer(kind=int32), public, parameter :: PG_DIAG_MESSAGE_HINT = ichar('H') integer(kind=int32), public, parameter :: PG_DIAG_STATEMENT_POSITION = ichar('P') integer(kind=int32), public, parameter :: PG_DIAG_INTERNAL_POSITION = ichar('p') integer(kind=int32), public, parameter :: PG_DIAG_INTERNAL_QUERY = ichar('q') integer(kind=int32), public, parameter :: PG_DIAG_CONTEXT = ichar('W') integer(kind=int32), public, parameter :: PG_DIAG_SCHEMA_NAME = ichar('s') integer(kind=int32), public, parameter :: PG_DIAG_TABLE_NAME = ichar('t') integer(kind=int32), public, parameter :: PG_DIAG_COLUMN_NAME = ichar('c') integer(kind=int32), public, parameter :: PG_DIAG_DATATYPE_NAME = ichar('d') integer(kind=int32), public, parameter :: PG_DIAG_CONSTRAINT_NAME = ichar('n') integer(kind=int32), public, parameter :: PG_DIAG_SOURCE_FILE = ichar('F') integer(kind=int32), public, parameter :: PG_DIAG_SOURCE_LINE = ichar('L') integer(kind=int32), public, parameter :: PG_DIAG_SOURCE_FUNCTION = ichar('R')","tags":"","loc":"module/error_message_fields_m.html"},{"title":"character_operations_m – Libpq-Fortran","text":"Contents Functions max_length_char_array c_to_f_charpointer c_to_f_charpointer_with_length convert_cptr Subroutines cchar_array_from_strings cchar_array_from_strings_no_null cptr_array_from_cchar cptr_array_from_cchar_no_null read_option c_char_to_f_string Functions public  function max_length_char_array (array) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) Return Value integer(kind=int32) public  function c_to_f_charpointer (char_cptr) result(res) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: char_cptr Return Value character(kind=c_char, len=:), pointer public  function c_to_f_charpointer_with_length (char_cptr, length) result(res) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: char_cptr integer(kind=int32) :: length Return Value character(kind=c_char, len=length), pointer public  function convert_cptr (cptr, length) result(fptr) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cptr integer(kind=c_size_t), intent(in) :: length Return Value character(kind=c_char, len=length), pointer Subroutines public  subroutine cchar_array_from_strings (words, c_words, max_length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words (:) character(kind=c_char, len=max_length+1), intent(out), allocatable, target :: c_words (:) integer(kind=int32), intent(in) :: max_length public  subroutine cchar_array_from_strings_no_null (words, c_words, max_length) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words (:) character(kind=c_char, len=max_length+1), intent(out), allocatable, target :: c_words (:) integer(kind=int32), intent(in) :: max_length public  subroutine cptr_array_from_cchar (c_words, ptr_array) Arguments Type Intent Optional Attributes Name character(kind=c_char, len=*), intent(in), target :: c_words (:) type(c_ptr), intent(out), allocatable :: ptr_array (:) public  subroutine cptr_array_from_cchar_no_null (c_words, ptr_array) Arguments Type Intent Optional Attributes Name character(kind=c_char, len=*), intent(in), target :: c_words (:) type(c_ptr), intent(out), allocatable :: ptr_array (:) public  subroutine read_option (sizes, c_option, option) Arguments Type Intent Optional Attributes Name type( c_PQconnOptionSizes ), intent(in) :: sizes type( c_PQconninfoOption ), intent(inout) :: c_option type( PQconninfoOption ), intent(out) :: option public  subroutine c_char_to_f_string (cptr, str) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cptr character(len=:), intent(out), allocatable :: str","tags":"","loc":"module/character_operations_m.html"},{"title":"libpq – Libpq-Fortran","text":"Uses fe_misc_m PGnotify_t fe_connect_m iso_fortran_env PQconninfoOption_t error_message_fields_m enumerators_t fe_auth_m fe_exec_m Contents Variables InvalidOid Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: InvalidOid = 0","tags":"","loc":"module/libpq.html"},{"title":"PQconninfoOption_t – Libpq-Fortran","text":"Uses iso_c_binding iso_fortran_env Contents Variables CONNINFO_LABEL_LEN Derived Types PQconninfoOption c_PQconninfoOption c_PQconnOptionSizes Variables Type Visibility Attributes Name Initial integer, public, parameter :: CONNINFO_LABEL_LEN = 64 Derived Types type, public :: PQconninfoOption Components Type Visibility Attributes Name Initial character(len=CONNINFO_LABEL_LEN), public :: keyword character(len=CONNINFO_LABEL_LEN), public :: envvar character(len=CONNINFO_LABEL_LEN), public :: compiled character(len=CONNINFO_LABEL_LEN), public :: val character(len=CONNINFO_LABEL_LEN), public :: label character(len=1), public :: dispchar integer(kind=int32), public :: dispsize type, public :: c_PQconninfoOption Components Type Visibility Attributes Name Initial type(c_ptr), public :: keyword type(c_ptr), public :: envvar type(c_ptr), public :: compiled type(c_ptr), public :: val type(c_ptr), public :: label type(c_ptr), public :: dispchar integer(kind=c_int), public :: dispsize type, public :: c_PQconnOptionSizes Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: keyword integer(kind=c_int), public :: envvar integer(kind=c_int), public :: compiled integer(kind=c_int), public :: val integer(kind=c_int), public :: label integer(kind=c_int), public :: dispchar","tags":"","loc":"module/pqconninfooption_t.html"},{"title":"enumerators_t – Libpq-Fortran","text":"Contents Enumerations unnamed unnamed unnamed unnamed unnamed unnamed unnamed unnamed Enumerations enum, bind(c) Enumerators enumerator :: CONNECTION_OK = 0 enumerator :: CONNECTION_BAD = 1 enumerator :: CONNECTION_MADE = 2 enumerator :: CONNECTION_AWAITING_RESPONSE = 3 enumerator :: CONNECTION_AUTH_OK = 4 enumerator :: CONNECTION_SETENV = 5 enumerator :: CONNECTION_SSL_STARTUP = 6 enumerator :: CONNECTION_NEEDED = 7 enumerator :: CONNECTION_CHECK_WRITABLE = 8 enumerator :: CONNECTION_CONSUME = 9 enumerator :: CONNECTION_GSS_STARTUP = 10 enumerator :: CONNECTION_CHECK_TARGET = 11 enumerator :: CONNECTION_CHECK_STANDBY = 12 enum, bind(c) Enumerators enumerator :: PGRES_EMPTY_QUERY = 0 enumerator :: PGRES_COMMAND_OK = 1 enumerator :: PGRES_TUPLES_OK = 2 enumerator :: PGRES_COPY_OUT = 3 enumerator :: PGRES_COPY_IN = 4 enumerator :: PGRES_BAD_RESPONSE = 5 enumerator :: PGRES_NONFATAL_ERROR = 6 enumerator :: PGRES_FATAL_ERROR = 7 enumerator :: PGRES_COPY_BOTH = 8 enumerator :: PGRES_SINGLE_TUPLE = 9 enumerator :: PGRES_PIPELINE_SYNC = 10 enumerator :: PGRES_PIPELINE_ABORTED = 11 enum, bind(c) Enumerators enumerator :: PQPING_OK = 0 enumerator :: PQPING_REJECT = 1 enumerator :: PQPING_NO_RESPONSE = 2 enumerator :: PQPING_NO_ATTEMPT = 3 enum, bind(c) Enumerators enumerator :: PQ_PIPELINE_OFF = 0 enumerator :: PQ_PIPELINE_ON = 1 enumerator :: PQ_PIPELINE_ABORTED = 2 enum, bind(c) Enumerators enumerator :: PQTRANS_IDLE = 0 enumerator :: PQTRANS_ACTIVE = 1 enumerator :: PQTRANS_INTRANS = 2 enumerator :: PQTRANS_INERROR = 3 enumerator :: PQTRANS_UNKNOWN = 4 enum, bind(c) Enumerators enumerator :: PGRES_POLLING_FAILED = 0 enumerator :: PGRES_POLLING_READING = 1 enumerator :: PGRES_POLLING_WRITING = 2 enumerator :: PGRES_POLLING_OK = 3 enumerator :: PGRES_POLLING_ACTIVE = 4 enum, bind(c) Enumerators enumerator :: PQERRORS_TERSE = 0 enumerator :: PQERRORS_DEFAULT = 1 enumerator :: PQERRORS_VERBOSE = 2 enumerator :: PQERRORS_SQLSTATE = 3 enum, bind(c) Enumerators enumerator :: PQSHOW_CONTEXT_NEVER = 0 enumerator :: PQSHOW_CONTEXT_ERRORS = 1 enumerator :: PQSHOW_CONTEXT_ALWAYS = 2","tags":"","loc":"module/enumerators_t.html"},{"title":"PGnotify_t – Libpq-Fortran","text":"Uses iso_c_binding Contents Derived Types pgNotify Derived Types type, public :: pgNotify Components Type Visibility Attributes Name Initial type(c_ptr), public :: relname integer(kind=c_int), public :: be_pid type(c_ptr), public :: extra","tags":"","loc":"module/pgnotify_t.html"},{"title":"fe_connect_m – Libpq-Fortran","text":"Contents Functions PQconnectdb PQconnectdbParams PQsetdbLogin PQconnectStartParams PQconnectStart PQconnectPoll PQresetStart PQresetPoll PQpingParams PQping PQdb PQuser PQpass PQhost PQhostaddr PQport PQoptions PQstatus PQtransactionStatus PQparameterStatus PQprotocolVersion PQserverVersion PQerrorMessage PQsocket PQbackendPID PQconnectionNeedsPassword PQconnectionUsedPassword PQsslInUse PQgetCancel PQcancel PQclientEncoding PQsetClientEncoding PQsetErrorVerbosity PQsetErrorContextVisibility Subroutines PQconndefaults PQconninfo PQconninfoParse PQfinish PQreset PQsslAttribute PQsslAttributeNames PQfreeCancel Functions public  function PQconnectdb (conninfo) result(conn) Connect to the database server with the provided connection string conninfo . Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo PostgreSQL connection string Return Value type(c_ptr) public  function PQconnectdbParams (keywords, values, expand_dbname) result(conn) Connect to the database server with connection infomation provided as pairs of keywords and values arrays. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: keywords (:) Keywords, such as host , hostaddr , dbname , user , password , etc. character(len=*), intent(in) :: values (:) The array of each value corresponding to that keyword. integer :: expand_dbname Return Value type(c_ptr) public  function PQsetdbLogin (host, port, options, tty, dbName, login, pwd) result(conn) Connect to the database server with connection infomation provided as each argument Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: host Hostname character(len=*), intent(in) :: port Port number character(len=*), intent(in) :: options Options character(len=*), intent(in) :: tty Empty string character(len=*), intent(in) :: dbName The name of the database character(len=*), intent(in) :: login The user name at this login character(len=*), intent(in) :: pwd The password of the user Return Value type(c_ptr) public  function PQconnectStartParams (keywords, values, expand_dbname) result(conn) Connect to the database server in a nonblocking manner. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: keywords (:) character(len=*), intent(in) :: values (:) integer :: expand_dbname Return Value type(c_ptr) public  function PQconnectStart (conninfo) result(conn) Connect to the database server in a nonblocking manner. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo Return Value type(c_ptr) public  function PQconnectPoll (conn) Connect to the database server in a nonblocking manner. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr) :: conn Return Value integer(kind=int32) public  function PQresetStart (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQresetPoll (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQpingParams (keywords, values, expand_dbname) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: keywords (:) character(len=*), intent(in) :: values (:) integer, intent(in) :: expand_dbname Return Value integer(kind=c_int) public  function PQping (conninfo) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo Return Value integer(kind=int32) public  function PQdb (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQuser (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQpass (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQhost (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQhostaddr (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQport (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQoptions (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQstatus (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQtransactionStatus (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=c_int) public  function PQparameterStatus (conn, paramName) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: paramName Return Value character(len=:), pointer public  function PQprotocolVersion (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer public  function PQserverVersion (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer public  function PQerrorMessage (conn) result(PQerrormessage) Returns the error message most recently generated by an operation on the connection. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(kind=c_char, len=:), pointer public  function PQsocket (conn) Obtain the file descriptor number of the connection socket to the server. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=c_int) public  function PQbackendPID (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=c_int) public  function PQconnectionNeedsPassword (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQconnectionUsedPassword (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQsslInUse (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value logical public  function PQgetCancel (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value type(c_ptr) public  function PQcancel (cancel, errbuf, errbufsize) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cancel character(len=*), intent(inout) :: errbuf integer(kind=int32), intent(in) :: errbufsize Return Value integer(kind=int32) public  function PQclientEncoding (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value character(len=:), pointer public  function PQsetClientEncoding (conn, encoding) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: encoding Return Value integer(kind=int32) public  function PQsetErrorVerbosity (conn, verbosity) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: verbosity Return Value integer(kind=int32) public  function PQsetErrorContextVisibility (conn, show_context) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: show_context Return Value integer(kind=int32) Subroutines public  subroutine PQconndefaults (options) Get the default connection options. Read more… Arguments Type Intent Optional Attributes Name type( PQconninfoOption ), intent(out), dimension(:), allocatable, target :: options public  subroutine PQconninfo (conn, options) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn type( PQconninfoOption ), intent(out), dimension(:), allocatable, target :: options public  subroutine PQconninfoParse (conninfo, options, errmsg, errflag) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: conninfo type( PQconninfoOption ), intent(out), dimension(:), allocatable, target :: options character(len=*), intent(out) :: errmsg logical :: errflag public  subroutine PQfinish (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: conn public  subroutine PQreset (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: conn public  subroutine PQsslAttribute (conn, attribute_name, resultstr) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: attribute_name character(len=:), allocatable :: resultstr public  subroutine PQsslAttributeNames (conn, strings, len) Subroutine for retrieving SSL attribute names from a PostgreSQL \n database connection and populating an array. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=len), allocatable :: strings (:) integer(kind=int32), intent(in) :: len public  subroutine PQfreeCancel (cancel) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cancel","tags":"","loc":"module/fe_connect_m.html"},{"title":"fe_auth_m – Libpq-Fortran","text":"Contents Subroutines PQencryptPasswordConn Subroutines public  subroutine PQencryptPasswordConn (conn, passwd, user, algorithm, encrypted) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: passwd character(len=*), intent(in) :: user character(len=*), intent(in) :: algorithm character(len=*), intent(out) :: encrypted","tags":"","loc":"module/fe_auth_m.html"},{"title":"fe_misc_m – Libpq-Fortran","text":"Contents Functions PQlibVersion Functions public  function PQlibVersion () Get the current running version of libpq.\ncf. PostgreSQL Documentation Arguments None Return Value integer","tags":"","loc":"module/fe_misc_m.html"},{"title":"fe_exec_m – Libpq-Fortran","text":"Contents Interfaces PQexecParams PQprepare PQsendPrepare PQsendQueryPrepared PQsendQueryParams Functions PQexec PQexecPrepared PQdescribePrepared PQdescribePortal PQresultStatus PQresStatus PQresultErrorMessage PQresultVerboseErrorMessage PQresultErrorField PQntuples PQnfields PQfname PQfnumber PQftable PQftablecol PQfformat PQftype PQfmod PQfsize PQbinaryTuples PQgetvalue PQgetisnull PQgetlength PQnparams PQparamtype PQcmdStatus PQcmdTuples PQoidValue PQescapeLiteral PQescapeIdentifier PQsendQuery PQsendDescribePrepared PQsendDescribePortal PQgetResult PQconsumeInput PQisBusy PQsetnonblocking PQisnonblocking PQflush PQpipelineStatus PQenterPipelineMode PQexitPipelineMode PQpipelineSync PQsendFlushRequest PQsetSingleRowMode PQnotifies PQmakeEmptyPGresult PQcopyResult PQisthreadsafe Subroutines PQclear PQfreemem Interfaces public        interface PQexecParams private  function PQexecParams_int32(conn, command, nParams, paramTypes, paramValues) result(res) Submits a command to the server and waits for the result, with the ability to pass \nparameters separately from the SQL command text. PQexecParams is like PQexec but offers additional functionality:\nparameter values can be specified separately from the command string proper, and query results\ncan be requested in text or binary format. cf. PostgreSQL Documentation Note Binary format have not been implemented yet. Example block character (:), allocatable :: command character ( 8 ) :: values ( 2 ) type ( c_ptr ) :: res command = \"select $1::bigint + $2::bigint;\" values ( 1 ) = \"300\" values ( 2 ) = \"500\" res = PQexecParams ( conn , command , size ( values ), [ 0 , 0 ], values ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) call PQclear ( res ) end if print * , PQgetvalue ( res , 0 , 0 ) ! the result \"800\" is expected. call PQclear ( res ) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn The connection object to send the command through. character(len=*), intent(in) :: command The SQL command string to be executed. If parameters are used, \nthey are referred to in the command string as $1 , $2 , etc. integer(kind=int32), intent(in) :: nParams The number of parameters supplied; it is the length of the arrays paramTypes , paramValues . integer(kind=int32), intent(in) :: paramTypes (:) Specifies, by OID, the data types to be assigned to the parameter symbols.\nIf any particular element in the array is zero, the server infers a data type\nfor the parameter symbol in the same way it would do for an untyped literal string. character(len=*), intent(in) :: paramValues (:) Specifies the actual values of the parameters. A empty string in this array means\nthe corresponding parameter is null. Return Value type(c_ptr) private  function PQexecParams_int64(conn, command, nParams, paramTypes, paramValues) result(res) Submits a command to the server and waits for the result, with the ability to pass \nparameters separately from the SQL command text. PQexecParams is like PQexec but offers additional functionality:\nparameter values can be specified separately from the command string proper, and query results\ncan be requested in text or binary format. cf. PostgreSQL Documentation Note Binary format have not been implemented yet. Example block character (:), allocatable :: command character ( 8 ) :: values ( 2 ) type ( c_ptr ) :: res command = \"select $1::bigint + $2::bigint;\" values ( 1 ) = \"300\" values ( 2 ) = \"500\" res = PQexecParams ( conn , command , size ( values ), [ 0_8 , 0_8 ], values ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) call PQclear ( res ) end if print * , PQgetvalue ( res , 0 , 0 ) ! the result \"800\" is expected. call PQclear ( res ) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn The connection object to send the command through. character(len=*), intent(in) :: command The SQL command string to be executed. If parameters are used, \nthey are referred to in the command string as $1 , $2 , etc. integer(kind=int32), intent(in) :: nParams The number of parameters supplied; it is the length of the arrays paramTypes , paramValues . integer(kind=int64), intent(in) :: paramTypes (:) Specifies, by OID, the data types to be assigned to the parameter symbols.\nIf any particular element in the array is zero, the server infers a data type\nfor the parameter symbol in the same way it would do for an untyped literal string. character(len=*), intent(in) :: paramValues (:) Specifies the actual values of the parameters. A empty string in this array means\nthe corresponding parameter is null. Return Value type(c_ptr) public        interface PQprepare private  function PQprepare_int32(conn, stmtName, query, nParams, paramTypes) result(res) Submits a request to create a prepared statement with the given parameters, and waits for completion. PQprepare creates a prepared statement for later execution with PQexecPrepared .\nThis feature allows commands to be executed repeatedly without being parsed and\nplanned each time; see PREPARE for details. The function create a prepared statement named stmtName from the query string, which\nmust contain a single SQL command. stmtName can be \"\" to create an unnamed statement,\nin which case any pre-existing unnamed statement is automatically replaced; otherwise it is\nan error if the statement name is already defined in the current session. If any parameters are used, \nthey are referred to in the as $1 , $2 , etc. nParams is the number of parameters for which types\nare pre-specified in the array paramTypes . paramTypes specifies, by OID, the data types to be assigned to the parameter symbols. \nIf any particuler element in the paramTypes array is zero, the server assigns a data type to the\nparameter symbol in the same way it would do for an untyped literal string. \nAlso, the query can use parameter symbols with the numbers higher than nParams ; data types will \nbe inferred for these symbols as well. \n (See PQdescribePrepared ) for a means to find out what data types were inffered.) As with [[PQexec]] , the result is normally a PGresult object whose contents indicate server-side\nsuccess or failure. A null result indicates out-of-memory or inability to send to the command at all.\nUse PQerrorMessage to get more information about such errors. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int32), intent(in) :: paramTypes (:) Return Value type(c_ptr) private  function PQprepare_int64(conn, stmtName, query, nParams, paramTypes) result(res) Submits a request to create a prepared statement with the given parameters, and waits for completion. PQprepare creates a prepared statement for later execution with PQexecPrepared .\nThis feature allows commands to be executed repeatedly without being parsed and\nplanned each time; see PREPARE for details. The function create a prepared statement named stmtName from the query string, which\nmust contain a single SQL command. stmtName can be \"\" to create an unnamed statement,\nin which case any pre-existing unnamed statement is automatically replaced; otherwise it is\nan error if the statement name is already defined in the current session. If any parameters are used, \nthey are referred to in the as $1 , $2 , etc. nParams is the number of parameters for which types\nare pre-specified in the array paramTypes . paramTypes specifies, by OID, the data types to be assigned to the parameter symbols. \nIf any particuler element in the paramTypes array is zero, the server assigns a data type to the\nparameter symbol in the same way it would do for an untyped literal string. \nAlso, the query can use parameter symbols with the numbers higher than nParams ; data types will \nbe inferred for these symbols as well. As with PQexec , the result is normally a PGresult object whose contents indicate server-side\nsuccess or failure. A null result indicates out-of-memory or inability to send to the command at all.\nUse PQerrorMessage to get more information about such errors. cf. PostgreSQL Documentation cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int64), intent(in) :: paramTypes (:) Return Value type(c_ptr) public        interface PQsendPrepare private  function PQsendPrepare_int32(conn, stmtName, query, nParams, paramTypes) result(res) Sends a request to create a prepared statement with the given parameters, without waiting for completion. This is an asynchronous version of PQprepare :\nit returns 1 if it was able to dispatch the request, and 0 if not.\nAfter a successfull call, call PQgetResult to determine whether the server successfully created the prepared statement. \nThe function's parameters are handled identically to PQprepare . cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int32), intent(in) :: paramTypes (:) Return Value integer(kind=int32) private  function PQsendPrepare_int64(conn, stmtName, query, nParams, paramTypes) result(res) Sends a request to create a prepared statement with the given parameters, without waiting for completion. This is an asynchronous version of PQprepare :\nit returns 1 if it was able to dispatch the request, and 0 if not.\nAfter a successfull call, call PQgetResult to determine whether the server successfully created the prepared statement. \nThe function's parameters are handled identically to PQprepare . cf. PostgreSQL Documentation cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName character(len=*), intent(in) :: query integer(kind=int32), intent(in) :: nParams integer(kind=int64), intent(in) :: paramTypes (:) Return Value integer(kind=int32) public        interface PQsendQueryPrepared private  function PQsendQueryPrepared_text(conn, stmtName, nParams, paramValues) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName integer(kind=int32), intent(in) :: nParams character(len=*), intent(in) :: paramValues (:) Return Value integer(kind=int32) public        interface PQsendQueryParams private  function PQsendQueryParams_int32(conn, command, nParams, paramTypes, paramValues) result(res) Submit a command and separate parameter to the server without waiting for the result(s).\nThis is equivalent to PQsendQuery , except that query parameters can be specified\nseparately form the query string. \nThis function's parameters are handled identically PQexecParams .\nLike PQexecParams , it allows only one command in the query. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: command integer(kind=int32), intent(in) :: nParams integer(kind=int32), intent(in) :: paramTypes (:) character(len=*), intent(in) :: paramValues (:) Return Value integer(kind=int32) private  function PQsendQueryParams_int64(conn, command, nParams, paramTypes, paramValues) result(res) Submit a command and separate parameter to the server without waiting for the result(s).\nThis is equivalent to PQsendQuery , \nexcept that query parameters can be specified\nseparately form the query string. \nThis function's parameters are handled identically PQexecParams .\nLike PQexecParams , it allows only one command in the query. cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: command integer(kind=int32), intent(in) :: nParams integer(kind=int64), intent(in) :: paramTypes (:) character(len=*), intent(in) :: paramValues (:) Return Value integer(kind=int32) Functions public  function PQexec (conn, query) result(res) Send query to the server and wait until receiving the result. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: query Return Value type(c_ptr) public  function PQexecPrepared (conn, stmtName, nParams, paramValues) result(res) Sends a request to execute a prepared statement with given parameters, and waits for the result. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName integer(kind=int32), intent(in) :: nParams character(len=*), intent(in) :: paramValues (:) Return Value type(c_ptr) public  function PQdescribePrepared (conn, stmtName) result(res) Submits a request to obtain information about the specified prepared statement, and waits for completion. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName Return Value type(c_ptr) public  function PQdescribePortal (conn, portalName) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: portalName Return Value type(c_ptr) public  function PQresultStatus (pgresult) result(res) Returns the result status of the command. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) public  function PQresStatus (status) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: status Return Value character(len=:), pointer public  function PQresultErrorMessage (pgresult) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value character(kind=c_char, len=:), pointer public  function PQresultVerboseErrorMessage (pgresult, verbosity, show_context) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: verbosity integer(kind=int32), intent(in) :: show_context Return Value character(kind=c_char, len=:), pointer public  function PQresultErrorField (pgresult, fieldcode) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: fieldcode Return Value character(kind=c_char, len=:), pointer public  function PQntuples (pgresult) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) public  function PQnfields (pgresult) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) public  function PQfname (pgresult, field_num) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: field_num Return Value character(kind=c_char, len=:), pointer public  function PQfnumber (pgresult, column_name) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult character(len=*), intent(in) :: column_name Return Value integer public  function PQftable (pgresult, column_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int64) public  function PQftablecol (pgresult, column_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) public  function PQfformat (pgresult, column_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) public  function PQftype (pgresult, column_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int64) public  function PQfmod (pgresult, column_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) public  function PQfsize (pgresult, column_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: column_number Return Value integer(kind=int32) public  function PQbinaryTuples (pgresult) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value logical public  function PQgetvalue (pgresult, tuple_num, field_num) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=c_int), intent(in) :: tuple_num integer(kind=c_int), intent(in) :: field_num Return Value character(kind=c_char, len=:), pointer public  function PQgetisnull (pgresult, row_number, column_number) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: row_number integer(kind=int32), intent(in) :: column_number Return Value logical public  function PQgetlength (pgresult) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) public  function PQnparams (pgresult) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int32) public  function PQparamtype (pgresult, param_number) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult integer(kind=int32), intent(in) :: param_number Return Value integer(kind=int64) public  function PQcmdStatus (pgresult) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value character(len=:), pointer public  function PQcmdTuples (pgresult) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value character(len=:), pointer public  function PQoidValue (pgresult) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: pgresult Return Value integer(kind=int64) public  function PQescapeLiteral (conn, str, length, errmsg) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: str integer(kind=c_size_t), intent(in) :: length character(len=*), intent(inout), optional :: errmsg Return Value character(len=:), pointer public  function PQescapeIdentifier (conn, str, length, errmsg) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: str integer(kind=c_size_t), intent(in) :: length character(len=*), intent(inout), optional :: errmsg Return Value character(len=:), pointer public  function PQsendQuery (conn, command) result(res) Submits a command to the server without waiting for the result(s). 1 is returned if the command was successfully dispatched and 0 if not (in which case, use PQerrorMessage to get more information about the failure). Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: command Return Value integer(kind=int32) public  function PQsendDescribePrepared (conn, stmtName) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: stmtName Return Value integer(kind=int32) public  function PQsendDescribePortal (conn, portalName) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn character(len=*), intent(in) :: portalName Return Value integer(kind=int32) public  function PQgetResult (conn) result(res) Waits for the next result from a prior PQsendQuery , PQsendQueryParams , PQsendPrepare , PQsendQueryPrepared , PQsendDescribePrepared , PQsendDescribePortra , or PQpipelineSync call,\nand returns it.  A null pointer is returned when the command is complete and there will be no more results. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value type(c_ptr) public  function PQconsumeInput (conn) result(res) If input is available from the server, consume it. Read more… Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQisBusy (conn) result(isBusy) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value logical public  function PQsetnonblocking (conn, arg) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: arg Return Value integer(kind=int32) public  function PQisnonblocking (conn) result(isNonblocking) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value logical public  function PQflush (conn) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQpipelineStatus (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQenterPipelineMode (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQexitPipelineMode (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQpipelineSync (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQsendFlushRequest (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQsetSingleRowMode (conn) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value integer(kind=int32) public  function PQnotifies (conn) result(res) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn Return Value type(c_ptr) public  function PQmakeEmptyPGresult (conn, status) result(res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn integer(kind=int32), intent(in) :: status Return Value type(c_ptr) public  function PQcopyResult (conn, res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: conn type(c_ptr), intent(in) :: res Return Value type(c_ptr) public  function PQisthreadsafe () Get the threadsafety status of the current running libpq library.\ncf. PostgreSQL Documentation Arguments None Return Value logical Subroutines public  subroutine PQclear (res) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: res public  subroutine PQfreemem (cptr) cf. PostgreSQL Documentation Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cptr","tags":"","loc":"module/fe_exec_m.html"},{"title":"error_message_fields_m.f90 – Libpq-Fortran","text":"Contents Modules error_message_fields_m Source Code error_message_fields_m.f90 Source Code module error_message_fields_m use , intrinsic :: iso_fortran_env implicit none private integer ( int32 ), parameter , public :: PG_DIAG_SEVERITY = ichar ( 'S' ) integer ( int32 ), parameter , public :: PG_DIAG_SEVERITY_NONLOCALIZED = ichar ( 'V' ) integer ( int32 ), parameter , public :: PG_DIAG_SQLSTATE = ichar ( 'C' ) integer ( int32 ), parameter , public :: PG_DIAG_MESSAGE_PRIMARY = ichar ( 'M' ) integer ( int32 ), parameter , public :: PG_DIAG_MESSAGE_DETAIL = ichar ( 'D' ) integer ( int32 ), parameter , public :: PG_DIAG_MESSAGE_HINT = ichar ( 'H' ) integer ( int32 ), parameter , public :: PG_DIAG_STATEMENT_POSITION = ichar ( 'P' ) integer ( int32 ), parameter , public :: PG_DIAG_INTERNAL_POSITION = ichar ( 'p' ) integer ( int32 ), parameter , public :: PG_DIAG_INTERNAL_QUERY = ichar ( 'q' ) integer ( int32 ), parameter , public :: PG_DIAG_CONTEXT = ichar ( 'W' ) integer ( int32 ), parameter , public :: PG_DIAG_SCHEMA_NAME = ichar ( 's' ) integer ( int32 ), parameter , public :: PG_DIAG_TABLE_NAME = ichar ( 't' ) integer ( int32 ), parameter , public :: PG_DIAG_COLUMN_NAME = ichar ( 'c' ) integer ( int32 ), parameter , public :: PG_DIAG_DATATYPE_NAME = ichar ( 'd' ) integer ( int32 ), parameter , public :: PG_DIAG_CONSTRAINT_NAME = ichar ( 'n' ) integer ( int32 ), parameter , public :: PG_DIAG_SOURCE_FILE = ichar ( 'F' ) integer ( int32 ), parameter , public :: PG_DIAG_SOURCE_LINE = ichar ( 'L' ) integer ( int32 ), parameter , public :: PG_DIAG_SOURCE_FUNCTION = ichar ( 'R' ) end module error_message_fields_m","tags":"","loc":"sourcefile/error_message_fields_m.f90.html"},{"title":"character_operations_m.f90 – Libpq-Fortran","text":"Contents Modules character_operations_m Source Code character_operations_m.f90 Source Code module character_operations_m implicit none contains function max_length_char_array ( array ) result ( res ) use , intrinsic :: iso_fortran_env implicit none character ( * ), intent ( in ) :: array (:) integer ( int32 ) :: res , i res = 0 do i = lbound ( array , dim = 1 ), ubound ( array , dim = 1 ) res = max ( res , len_trim ( array ( i ))) end do end function max_length_char_array subroutine cchar_array_from_strings ( words , c_words , max_length ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none character ( * ), intent ( in ) :: words (:) integer ( int32 ), intent ( in ) :: max_length character ( max_length + 1 , kind = c_char ), intent ( out ), & allocatable , target :: c_words (:) integer :: i , siz siz = size ( words , dim = 1 ) allocate ( c_words ( siz + 1 ) ) do i = 1 , siz c_words ( i ) = trim ( adjustl ( words ( i ))) // c_null_char end do ! 最後の要素はNull文字を代入する。 c_words ( siz + 1 ) = c_null_char end subroutine cchar_array_from_strings subroutine cchar_array_from_strings_no_null ( words , c_words , max_length ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none character ( * ), intent ( in ) :: words (:) integer ( int32 ), intent ( in ) :: max_length character ( max_length + 1 , kind = c_char ), intent ( out ), allocatable , target :: c_words (:) integer :: i , siz siz = size ( words , dim = 1 ) allocate ( c_words ( siz )) do i = 1 , siz c_words ( i ) = trim ( adjustl ( words ( i ))) // c_null_char end do end subroutine cchar_array_from_strings_no_null ! Input: c_words ! Output: ptr_array (with null pointer termination) subroutine cptr_array_from_cchar ( c_words , ptr_array ) use , intrinsic :: iso_c_binding implicit none character ( * , kind = c_char ), intent ( in ), target :: c_words (:) type ( c_ptr ), allocatable , intent ( out ) :: ptr_array (:) integer :: siz , i siz = size ( c_words , dim = 1 ) allocate ( ptr_array ( siz + 1 )) do i = 1 , siz ptr_array ( i ) = c_loc ( c_words ( i )) end do ptr_array ( siz ) = c_null_ptr end subroutine cptr_array_from_cchar ! Input: c_words ! Output: ptr_array (with null pointer termination) subroutine cptr_array_from_cchar_no_null ( c_words , ptr_array ) use , intrinsic :: iso_c_binding implicit none character ( * , kind = c_char ), intent ( in ), target :: c_words (:) type ( c_ptr ), allocatable , intent ( out ) :: ptr_array (:) integer :: siz , i siz = size ( c_words , dim = 1 ) allocate ( ptr_array ( siz + 1 )) do i = 1 , siz ptr_array ( i ) = c_loc ( c_words ( i )) end do end subroutine cptr_array_from_cchar_no_null subroutine read_option ( sizes , c_option , option ) use :: PQconninfoOption_t use , intrinsic :: iso_c_binding implicit none type ( c_PQconnoptionSizes ), intent ( in ) :: sizes type ( c_PQconninfoOption ), intent ( inout ) :: c_option type ( PQconninfoOption ), intent ( out ) :: option ! Cの構造体からFortranの派生型に、keywordの値をコピーする。 block character ( sizes % keyword ), pointer :: keyword call c_f_pointer ( c_option % keyword , keyword ) option % keyword = trim ( keyword ) end block if ( sizes % envvar > 0 ) then block character ( sizes % envvar ), pointer :: envvar call c_f_pointer ( c_option % envvar , envvar ) option % envvar = trim ( envvar ) end block else option % envvar = '' end if if ( sizes % compiled > 0 ) then block character ( sizes % compiled ), pointer :: compiled call c_f_pointer ( c_option % compiled , compiled ) option % compiled = trim ( compiled ) end block else option % compiled = '' end if if ( sizes % val > 0 ) then block character ( sizes % val ), pointer :: val call c_f_pointer ( c_option % val , val ) option % val = trim ( val ) end block else option % val = '' end if if ( sizes % label > 0 ) then block character ( sizes % label ), pointer :: label call c_f_pointer ( c_option % label , label ) option % label = trim ( label ) end block else option % label = '' end if if ( sizes % dispchar > 0 ) then block character ( 1 ), pointer :: dispchar call c_f_pointer ( c_option % dispchar , dispchar ) option % dispchar = trim ( dispchar ) end block else option % dispchar = '' end if block option % dispsize = c_option % dispsize end block end subroutine read_option subroutine c_char_to_f_string ( cptr , str ) use , intrinsic :: iso_c_binding , only : c_ptr , c_char , c_size_t use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: cptr character (:), allocatable , intent ( out ) :: str character (:, kind = c_char ), allocatable :: buf integer ( c_size_t ) :: length interface ! Interface to 'strlen' C function function strlen ( ptr ) bind ( c ) import c_ptr , c_size_t type ( c_ptr ), intent ( in ), value :: ptr integer ( c_size_t ) :: strlen end function strlen end interface length = strlen ( cptr ) call convert_cptr ( cptr , length , buf ) str = buf contains ! `convert_cptr` takes a string with type(cptr) and its length as input, ! and returns a corresponding Fortran pointer of character-type. subroutine convert_cptr ( cptr , length , buf ) use , intrinsic :: iso_c_binding , only : c_ptr , c_size_t , c_f_pointer , c_char implicit none type ( c_ptr ), intent ( in ) :: cptr integer ( c_size_t ), intent ( in ) :: length character (:, kind = c_char ), allocatable , intent ( out ) :: buf ! Declare a character-type pointer variable `fptr` with a length `length` and ! a kind parameter `c_char`. character ( len = length , kind = c_char ), pointer :: fptr call c_f_pointer ( cptr , fptr ) buf = fptr end subroutine convert_cptr end subroutine c_char_to_f_string ! `c_to_f_charpointer` function takes a pointer to a string with type(c_ptr) as input, ! and returns a corresponding Fortran pointer of character-type. function c_to_f_charpointer ( char_cptr ) result ( res ) use , intrinsic :: iso_c_binding , only : c_ptr , c_char , c_size_t implicit none type ( c_ptr ), intent ( in ), value :: char_cptr character (:, kind = c_char ), pointer :: res interface ! Interface to 'strlen' C function function strlen ( ptr ) bind ( c ) import c_ptr , c_size_t type ( c_ptr ), value :: ptr integer ( c_size_t ) :: strlen end function strlen end interface ! Associate the pointer variable `res` with the result of the function `convert_cptr`. res => convert_cptr ( char_cptr , strlen ( char_cptr )) end function c_to_f_charpointer function c_to_f_charpointer_with_length ( char_cptr , length ) result ( res ) use , intrinsic :: iso_c_binding , only : c_ptr , c_char use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: char_cptr integer ( int32 ) :: length character ( length , kind = c_char ), pointer :: res res => convert_cptr ( char_cptr , int ( length , int64 )) end function ! `convert_cptr` takes a string with type(cptr) and its length as input, ! and returns a corresponding Fortran pointer of character-type. function convert_cptr ( cptr , length ) result ( fptr ) use , intrinsic :: iso_c_binding , only : c_ptr , c_size_t , c_f_pointer , c_char implicit none type ( c_ptr ), intent ( in ) :: cptr integer ( c_size_t ), intent ( in ) :: length ! Declare a character-type pointer variable `fptr` with a length `length` and ! a kind parameter `c_char`. character ( len = length , kind = c_char ), pointer :: fptr call c_f_pointer ( cptr , fptr ) end function convert_cptr end module character_operations_m","tags":"","loc":"sourcefile/character_operations_m.f90.html"},{"title":"libpq.f90 – Libpq-Fortran","text":"Contents Modules libpq Source Code libpq.f90 Source Code module libpq use , intrinsic :: iso_fortran_env , only : int64 use :: error_message_fields_m use :: fe_connect_m , & only : PQconnectdb , PQfinish , PQstatus , PQerrorMessage , & PQping , PQdb , PQuser , PQhost , PQhostaddr , PQconnectdbParams , & PQoptions , PQtransactionStatus , PQsetdbLogin , PQpingParams , & PQreset , PQpass , PQport , PQprotocolVersion , PQserverVersion , & PQconndefaults , PQconnectStart , PQconnectStartParams , & PQconnectPoll , PQbackendPID , PQsocket , PQresetStart , & PQresetPoll , PQparameterStatus , PQconnectionNeedsPassword , & PQconnectionUsedPassword , PQconninfo , PQconninfoParse , & PQclientEncoding , PQsetClientEncoding , PQsslInUse , & PQsslAttribute , PQgetCancel , PQfreeCancel , PQcancel , & PQsslAttributeNames , PQsetErrorVerbosity , PQsetErrorContextVisibility use :: fe_exec_m , & only : PQexec , PQresultStatus , PQntuples , PQnfields , & PQgetvalue , PQclear , PQresultErrorMessage , PQfname , & PQfnumber , PQgetisnull , PQresultVerboseErrorMessage , & PQbinaryTuples , PQftablecol , PQfformat , PQfmod , PQfsize , & PQftable , PQftype , PQresStatus , PQgetlength , PQnparams , & PQparamtype , PQresultErrorField , PQcmdStatus , PQcmdTuples , & PQoidValue , & PQsendQuery , PQgetResult , PQconsumeInput , PQisBusy , & PQsetnonblocking , PQisnonblocking , PQflush , PQescapeLiteral , & PQescapeIdentifier , PQexecParams , PQprepare , PQexecPrepared , & PQdescribePrepared , PQdescribePortal , PQnparams , PQparamtype , & PQsendPrepare , PQsendQueryPrepared , PQsendDescribePrepared , & PQsendDescribePortal , & PQpipelineStatus , PQenterPipelineMode , PQexitPipelineMode , & PQpipelineSync , PQsendFlushRequest , PQsetSingleRowMode , & PQsendQueryParams , PQisthreadsafe , PQmakeEmptyPGresult , & PQcopyResult , PQnotifies , PQfreemem use :: fe_auth_m , only : PQencryptPasswordConn use :: fe_misc_m , only : PQlibVersion use :: PQconninfoOption_t , only : PQconninfoOption use :: PGnotify_t , only : PGnotify use :: enumerators_t implicit none private !------------------------------------------------------------------! !-- Parameters integer ( int64 ), parameter , public :: InvalidOid = 0 !------------------------------------------------------------------! !-- PUBLIC Statements !-From module m_fe_connect: ! Database Connection Control Functions public :: PQconnectdb public :: PQconnectdbParams public :: PQfinish public :: PQerrorMessage public :: PQping public :: PQsetdbLogin public :: PQpingParams public :: PQreset public :: PQconndefaults public :: PQconnectStart public :: PQconnectStartParams public :: PQconnectPoll public :: PQresetPoll public :: PQresetStart public :: PQconninfo public :: PQconninfoParse ! Connction Status Functions public :: PQdb public :: PQuser public :: PQpass public :: PQhost public :: PQport public :: PQhostaddr public :: PQoptions public :: PQstatus public :: PQtransactionStatus public :: PQserverVersion public :: PQprotocolVersion public :: PQsocket public :: PQbackendPID public :: PQparameterStatus public :: PQconnectionNeedsPassword public :: PQconnectionUsedPassword public :: PQsslInUse public :: PQsslAttribute public :: PQsslAttributeNames ! Cancel public :: PQgetCancel public :: PQfreeCancel public :: PQcancel ! Notification public :: PQnotifies ! Misc. public :: PQclientEncoding public :: PQsetClientEncoding public :: PQsetErrorVerbosity public :: PQsetErrorContextVisibility !-From module m_fe_exec: public :: PQexec public :: PQexecParams public :: PQprepare public :: PQexecPrepared public :: PQdescribePrepared public :: PQdescribePortal public :: PQresultStatus public :: PQresultErrorMessage public :: PQresultVerboseErrorMessage public :: PQntuples public :: PQnfields public :: PQfname public :: PQfnumber public :: PQgetvalue public :: PQgetisnull public :: PQnparams public :: PQparamtype public :: PQclear public :: PQbinaryTuples public :: PQfformat public :: PQfmod public :: PQfsize public :: PQftablecol public :: PQftable public :: PQftype public :: PQresStatus public :: PQgetlength public :: PQresultErrorField public :: PQcmdStatus public :: PQcmdTuples public :: PQoidValue public :: PQsendQuery public :: PQsendQueryParams public :: PQsendPrepare public :: PQsendQueryPrepared public :: PQsendDescribePrepared public :: PQsendDescribePortal public :: PQgetResult public :: PQconsumeInput public :: PQisBusy public :: PQsetnonblocking public :: PQisnonblocking public :: PQflush public :: PQpipelineStatus public :: PQenterPipelineMode public :: PQexitPipelineMode public :: PQpipelineSync public :: PQsendFlushRequest public :: PQescapeLiteral public :: PQescapeIdentifier public :: PQfreemem public :: PQisthreadsafe ! From module m_fe_misc public :: PQlibVersion ! From module m_fe_auth public :: PQencryptPasswordConn ! Derived types public :: PQconninfoOption public :: pgNotify ! enumerators_t public :: CONNECTION_OK , CONNECTION_BAD , & CONNECTION_MADE , & CONNECTION_AWAITING_RESPONSE , & CONNECTION_AUTH_OK , & CONNECTION_SETENV , & CONNECTION_SSL_STARTUP , & CONNECTION_NEEDED , & CONNECTION_CHECK_WRITABLE , & CONNECTION_CONSUME , & CONNECTION_GSS_STARTUP , & CONNECTION_CHECK_TARGET , & CONNECTION_CHECK_STANDBY public :: PQPING_OK , PQPING_REJECT , PQPING_NO_RESPONSE , & PQPING_NO_ATTEMPT public :: PQTRANS_IDLE , PQTRANS_ACTIVE , PQTRANS_INTRANS , & PQTRANS_INERROR , PQTRANS_UNKNOWN public :: PGRES_POLLING_FAILED , PGRES_POLLING_READING , & PGRES_POLLING_WRITING , PGRES_POLLING_OK , & PGRES_POLLING_ACTIVE public :: PQ_PIPELINE_OFF , PQ_PIPELINE_ON , PQ_PIPELINE_ABORTED public :: PQERRORS_TERSE , PQERRORS_DEFAULT , PQERRORS_VERBOSE , PQERRORS_SQLSTATE public :: PQSHOW_CONTEXT_NEVER , PQSHOW_CONTEXT_ERRORS , PQSHOW_CONTEXT_ALWAYS public :: PGRES_EMPTY_QUERY , PGRES_COMMAND_OK , PGRES_TUPLES_OK , & PGRES_COPY_OUT , PGRES_COPY_IN , PGRES_BAD_RESPONSE , PGRES_NONFATAL_ERROR , & PGRES_FATAL_ERROR , PGRES_COPY_BOTH , PGRES_SINGLE_TUPLE , PGRES_PIPELINE_SYNC , & PGRES_PIPELINE_ABORTED end module libpq","tags":"","loc":"sourcefile/libpq.f90.html"},{"title":"PQconninfoOption_t.f90 – Libpq-Fortran","text":"Contents Modules PQconninfoOption_t Source Code PQconninfoOption_t.f90 Source Code module PQconninfoOption_t use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none ! Quote from 218-240 lines of postgresql-15.4/src/libpq-fe.h !/* ---------------- ! * Structure for the conninfo parameter definitions returned by PQconndefaults ! * or PQconninfoParse. ! * ! * All fields except \"val\" point at static strings which must not be altered. ! * \"val\" is either NULL or a malloc'd current-value string.  PQconninfoFree() ! * will release both the val strings and the PQconninfoOption array itself. ! * ---------------- ! */ !   typedef struct _PQconninfoOption !   { !      char\t   *keyword;\t\t/* The keyword of the option\t\t\t*/ !      char\t   *envvar;\t\t\t/* Fallback environment variable name\t*/ !      char\t   *compiled;\t\t/* Fallback compiled in default value\t*/ !      char\t   *val;\t\t\t/* Option's current value, or NULL\t\t */ !      char\t   *label;\t\t\t/* Label for field in connect dialog\t*/ !      char\t   *dispchar;\t\t/* Indicates how to display this field in a !                            * connect dialog. Values are: \"\" Display !                            * entered value as is \"*\" Password field - !                            * hide value \"D\"  Debug option - don't show !                            * by default */ !      int\t\t\tdispsize;\t\t/* Field size in characters for dialog\t*/ !   } PQconninfoOption; ! END Quote integer , parameter :: CONNINFO_LABEL_LEN = 64 type , public :: PQconninfoOption character ( CONNINFO_LABEL_LEN ) :: keyword character ( CONNINFO_LABEL_LEN ) :: envvar character ( CONNINFO_LABEL_LEN ) :: compiled character ( CONNINFO_LABEL_LEN ) :: val character ( CONNINFO_LABEL_LEN ) :: label character ( 1 ) :: dispchar integer ( int32 ) :: dispsize end type type , public :: c_PQconninfoOption type ( c_ptr ) :: keyword type ( c_ptr ) :: envvar type ( c_ptr ) :: compiled type ( c_ptr ) :: val type ( c_ptr ) :: label type ( c_ptr ) :: dispchar integer ( c_int ) :: dispsize end type type , public :: c_PQconnOptionSizes integer ( c_int ) :: keyword integer ( c_int ) :: envvar integer ( c_int ) :: compiled integer ( c_int ) :: val integer ( c_int ) :: label integer ( c_int ) :: dispchar end type end module PQconninfoOption_t","tags":"","loc":"sourcefile/pqconninfooption_t.f90.html"},{"title":"enumerators_t.f90 – Libpq-Fortran","text":"Contents Modules enumerators_t Source Code enumerators_t.f90 Source Code module enumerators_t implicit none !------------------------------------------------------------------! !-- ENUMERATOR declarations enum , bind ( c ) ! ConnStatusType in src/interfaces/libpq/libpq-fe.h enumerator :: CONNECTION_OK = 0 enumerator :: CONNECTION_BAD enumerator :: CONNECTION_MADE enumerator :: CONNECTION_AWAITING_RESPONSE enumerator :: CONNECTION_AUTH_OK enumerator :: CONNECTION_SETENV enumerator :: CONNECTION_SSL_STARTUP enumerator :: CONNECTION_NEEDED enumerator :: CONNECTION_CHECK_WRITABLE enumerator :: CONNECTION_CONSUME enumerator :: CONNECTION_GSS_STARTUP enumerator :: CONNECTION_CHECK_TARGET enumerator :: CONNECTION_CHECK_STANDBY end enum enum , bind ( c ) ! ExecStatusType in src/interfaces/libpq/libpq-fe.h enumerator :: PGRES_EMPTY_QUERY = 0 enumerator :: PGRES_COMMAND_OK enumerator :: PGRES_TUPLES_OK enumerator :: PGRES_COPY_OUT enumerator :: PGRES_COPY_IN enumerator :: PGRES_BAD_RESPONSE enumerator :: PGRES_NONFATAL_ERROR enumerator :: PGRES_FATAL_ERROR enumerator :: PGRES_COPY_BOTH enumerator :: PGRES_SINGLE_TUPLE enumerator :: PGRES_PIPELINE_SYNC enumerator :: PGRES_PIPELINE_ABORTED end enum enum , bind ( c ) ! PGPing in src/interfaces/libpq/libpq-fe.h enumerator :: PQPING_OK = 0 enumerator :: PQPING_REJECT enumerator :: PQPING_NO_RESPONSE enumerator :: PQPING_NO_ATTEMPT end enum enum , bind ( c ) ! PGpipelineStatus enumerator :: PQ_PIPELINE_OFF = 0 enumerator :: PQ_PIPELINE_ON enumerator :: PQ_PIPELINE_ABORTED end enum enum , bind ( c ) ! PGTransactionStatusType enumerator :: PQTRANS_IDLE = 0 enumerator :: PQTRANS_ACTIVE enumerator :: PQTRANS_INTRANS enumerator :: PQTRANS_INERROR enumerator :: PQTRANS_UNKNOWN end enum enum , bind ( c ) ! PostgresPollingStatusType enumerator :: PGRES_POLLING_FAILED = 0 enumerator :: PGRES_POLLING_READING enumerator :: PGRES_POLLING_WRITING enumerator :: PGRES_POLLING_OK enumerator :: PGRES_POLLING_ACTIVE end enum enum , bind ( c ) ! PGverbosity enumerator :: PQERRORS_TERSE = 0 enumerator :: PQERRORS_DEFAULT enumerator :: PQERRORS_VERBOSE enumerator :: PQERRORS_SQLSTATE end enum enum , bind ( c ) ! PQContextVisibility enumerator :: PQSHOW_CONTEXT_NEVER = 0 enumerator :: PQSHOW_CONTEXT_ERRORS enumerator :: PQSHOW_CONTEXT_ALWAYS end enum end module enumerators_t","tags":"","loc":"sourcefile/enumerators_t.f90.html"},{"title":"PGnotify_t.f90 – Libpq-Fortran","text":"Contents Modules PGnotify_t Source Code PGnotify_t.f90 Source Code module PGnotify_t use , intrinsic :: iso_c_binding implicit none private type , public , bind ( c ) :: pgNotify type ( c_ptr ) :: relname integer ( c_int ) :: be_pid type ( c_ptr ) :: extra end type pgNotify end module PGnotify_t","tags":"","loc":"sourcefile/pgnotify_t.f90.html"},{"title":"fe-connect.f90 – Libpq-Fortran","text":"Contents Modules fe_connect_m Source Code fe-connect.f90 Source Code module fe_connect_m implicit none private public :: PQconnectdb public :: PQconnectdbParams public :: PQdb public :: PQhost public :: PQping public :: PQuser public :: PQpass public :: PQport public :: PQhostaddr public :: PQstatus public :: PQfinish public :: PQerrorMessage public :: PQoptions public :: PQtransactionStatus public :: PQsetdbLogin public :: PQpingParams public :: PQreset public :: PQserverVersion public :: PQprotocolVersion public :: PQconndefaults public :: PQconnectStart public :: PQconnectStartParams public :: PQconnectPoll public :: PQsocket public :: PQbackendPID public :: PQresetPoll public :: PQresetStart public :: PQparameterStatus public :: PQconnectionNeedsPassword public :: PQconnectionUsedPassword public :: PQconninfo public :: PQconninfoParse public :: PQclientEncoding public :: PQsetClientEncoding public :: PQsslInUse public :: PQsslAttribute public :: PQsslAttributeNames public :: PQgetCancel public :: PQfreeCancel public :: PQcancel public :: PQsetErrorVerbosity public :: PQsetErrorContextVisibility ! PRIVATE functions private :: PQconnectdbParams_back contains !==================================================================! ! Database Connection Control Functions !> Connect to the database server with the provided connection string `conninfo`. function PQconnectdb ( conninfo ) result ( conn ) use , intrinsic :: iso_c_binding , only : c_char , c_ptr , c_null_char implicit none !> PostgreSQL connection string character ( * ), intent ( in ) :: conninfo character (:, kind = c_char ), allocatable :: c_conninfo type ( c_ptr ) :: conn interface ! Interface to PQconnectdb in interface/libpq/fe-connect.c: ! ! PGconn *PQconnectdb(const char *conninfo) function c_PQ_connectdb ( info ) bind ( c , name = \"PQconnectdb\" ) result ( conn ) import c_ptr , c_char implicit none character ( 1 , kind = c_char ), intent ( in ) :: info ( * ) type ( c_ptr ) :: conn end function end interface c_conninfo = conninfo // c_null_char conn = c_PQ_connectdb ( c_conninfo ) !*### Example !```Fortran !   character(:), allocatable :: conninfo !   type(c_ptr) :: conn ! !   conninfo = \"host=localhost user=postgres dbname=postgres password=foobar\" ! !   conn = PQcoonectdb(conninfo) ! !   ! Error handling !   if (PQstatus(conn) /= CONNECTION_OK) then !      print *, PQerrorMessage(conn) !   end if !``` !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNECTDB) end function PQconnectdb !> Connect to the database server with connection infomation provided as pairs of `keywords` and `values` arrays. function PQconnectdbParams ( keywords , values , expand_dbname ) result ( conn ) use , intrinsic :: iso_c_binding !> Keywords, such as `host`, `hostaddr`, `dbname`, `user`, `password`, etc. character ( * ), intent ( in ) :: keywords (:) !> The array of each value corresponding to that keyword. character ( * ), intent ( in ) :: values (:) integer :: expand_dbname type ( c_ptr ) :: conn conn = PQconnectdbParams_back ( keywords , values , expand_dbname , . false .) !*### Example !```Fortran !   character(16) :: keywords(3), values(3) !   type(c_ptr) :: conn ! !   keywords(1) = 'host';   values(1) = 'localhost' !   keywords(2) = 'user';   values(2) = 'postgres' !   keywords(3) = 'dbname'; values(3) = 'postgres' ! !   conn = PQconnectdbParams(keywords, values, 0) ! !   ! Error handling !   if (PQstatus(conn) /= CONNECTION_OK) then !      print *, PQerrorMessage(conn) !   end if !``` !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS) end function PQconnectdbParams function PQconnectdbParams_back ( keywords , values , expand_dbname , isNonblocking ) result ( conn ) use :: character_operations_m use , intrinsic :: iso_c_binding , only : c_ptr , c_int , c_char ,& c_null_char , c_null_ptr , c_loc , c_associated implicit none ! NULL終端ではない配列を受け取る character ( * ), intent ( in ) :: keywords (:) character ( * ), intent ( in ) :: values (:) integer :: expand_dbname logical :: isNonblocking type ( c_ptr ) :: conn integer :: max_len_key , max_len_val interface function c_PQ_connectdb_params ( keywords , values , expand_dbname ) & bind ( c , name = \"PQconnectdbParams\" ) result ( conn ) import c_ptr , c_int implicit none ! ポインタの配列を渡すのでvalue属性は付けない。 type ( c_ptr ), intent ( in ), value :: keywords ! an array of pointers type ( c_ptr ), intent ( in ), value :: values ! an array of pointers integer ( c_int ), intent ( in ) :: expand_dbname type ( c_ptr ) :: conn end function c_PQ_connectdb_params end interface interface function c_PQ_connect_start_params ( keywords , values , expand_dbname ) & bind ( c , name = \"PQconnectStartParams\" ) result ( conn ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: keywords type ( c_ptr ), intent ( in ), value :: values integer ( c_int ), intent ( in ) :: expand_dbname type ( c_ptr ) :: conn end function c_PQ_connect_start_params end interface ! 下で確保する文字列配列の長さを知る。 max_len_key = max_length_char_array ( keywords ) max_len_val = max_length_char_array ( values ) block ! null文字をつけるために最大値よりも1だけ大きい文字列を宣言する。 character ( max_len_key + 1 , kind = c_char ), allocatable , target :: c_keys (:) character ( max_len_val + 1 , kind = c_char ), allocatable , target :: c_values (:) ! ポインタの配列を宣言する。 type ( c_ptr ), allocatable , target :: ptr_keys (:) type ( c_ptr ), allocatable , target :: ptr_values (:) ! c_int型整数を宣言する。 integer ( c_int ) :: c_expand_dbname ! keywordsについて、Cに渡す文字列の配列を用意する。 call cchar_array_from_strings ( keywords , c_keys , max_len_key ) ! keywordsについて、Cに渡すポインタの配列を用意する。 call cptr_array_from_cchar ( c_keys , ptr_keys ) ! valuesについて、Cに渡す文字列の配列を用意する。 call cchar_array_from_strings ( values , c_values , max_len_val ) ! valuesについて、Cに渡すポインタの配列を用意する。 call cptr_array_from_cchar ( c_values , ptr_values ) c_expand_dbname = expand_dbname ! ノンブロッキング接続かどうかで分岐する。 if ( isNonblocking ) then conn = c_PQ_connect_start_params ( c_loc ( ptr_keys ( 1 )), c_loc ( ptr_values ( 1 )), c_expand_dbname ) else conn = c_PQ_connectdb_params ( c_loc ( ptr_keys ( 1 )), c_loc ( ptr_values ( 1 )), c_expand_dbname ) end if end block end function PQconnectdbParams_back !> Connect to the database server with connection infomation provided as each argument function PQsetdbLogin ( host , port , options , tty , dbName , login , pwd ) result ( conn ) use , intrinsic :: iso_c_binding implicit none !> Hostname character ( * ), intent ( in ) :: host !> Port number character ( * ), intent ( in ) :: port !> Options character ( * ), intent ( in ) :: options !> Empty string character ( * ), intent ( in ) :: tty !> The name of the database character ( * ), intent ( in ) :: dbName !> The user name at this login character ( * ), intent ( in ) :: login !> The password of the user character ( * ), intent ( in ) :: pwd type ( c_ptr ) :: conn interface function c_PQ_setdb_login ( pghost , pgport , pgoptions , pgtty , dbName , login , pwd ) & bind ( c , name = 'PQsetdbLogin' ) result ( res ) import c_ptr , c_char implicit none character ( 1 , kind = c_char ), intent ( in ) :: pghost ( * ) character ( 1 , kind = c_char ), intent ( in ) :: pgport ( * ) character ( 1 , kind = c_char ), intent ( in ) :: pgoptions ( * ) character ( 1 , kind = c_char ), intent ( in ) :: pgtty ( * ) character ( 1 , kind = c_char ), intent ( in ) :: dbName ( * ) character ( 1 , kind = c_char ), intent ( in ) :: login ( * ) character ( 1 , kind = c_char ), intent ( in ) :: pwd ( * ) type ( c_ptr ) :: res end function c_PQ_setdb_login end interface block character (:, kind = c_char ), allocatable :: c_host , c_port , & c_options , c_tty , c_dbName , & c_login , c_pwd ! Cの関数にわたす文字列の末尾にNULL文字をつける。 c_host = host // c_null_char c_port = port // c_null_char c_options = options // c_null_char c_tty = tty // c_null_char c_dbName = dbName // c_null_char c_login = login // c_null_char c_pwd = pwd // c_null_char conn = c_PQ_setdb_login ( c_host , c_port , c_options , c_tty , c_dbName , c_login , c_pwd ) end block !*### Example !```Fortran !   type(c_ptr) :: conn ! !   conn = PQsetdbLogin(\"localhost\", \"5432\", \"\", \"\", \"postgres\",\"postgres\", \"\") ! !   ! Error handling !   if (PQstatus(conn) /= CONNECTION_OK) then !      print *, PQerrorMessage(conn) !   end if !``` !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQSETDBLOGIN) end function PQsetdbLogin !> Connect to the database server in a nonblocking manner. function PQconnectStartParams ( keywords , values , expand_dbname ) result ( conn ) use , intrinsic :: iso_c_binding character ( * ), intent ( in ) :: keywords (:) character ( * ), intent ( in ) :: values (:) integer :: expand_dbname type ( c_ptr ) :: conn conn = PQconnectdbParams_back ( keywords , values , expand_dbname , . true .) !*### Example !```Fortran !   type(c_ptr) :: conn !   integer :: res = -1 !   character(16) :: keywords(3), values(3) !   type(c_ptr) :: conn ! !   keywords(1) = 'host';   values(1) = 'localhost' !   keywords(2) = 'user';   values(2) = 'postgres' !   keywords(3) = 'dbname'; values(3) = 'postgres' ! !   conn = PQconnectStartParams(keywords, values, 0) ! !   if (c_associated(conn)) then !      do while(res /= PGRES_POLLING_OK) ! loop for polling ! !         res = PQconnectPoll(conn) !         select case (res) !         case (PGRES_POLLING_FAILED) !            print *, PQerrorMessage(conn) !            error stop !         case (PGRES_POLLING_OK) !            print *, \"CONNECTION ESTABLISHED\" !            exit !         case default !            continue !            ! write some process here! !         end select ! !      end do !   else !      print *, \"Cannot connect the server.\" !      error stop !   end if !``` !*### References ! cf. [[PQconnectStart]], [[PQconnectPoll]] !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS) end function PQconnectStartParams !> Connect to the database server in a nonblocking manner. function PQconnectStart ( conninfo ) result ( conn ) use , intrinsic :: iso_c_binding , only : c_char , c_ptr , c_null_char implicit none character ( * ), intent ( in ) :: conninfo character (:, kind = c_char ), allocatable :: c_conninfo type ( c_ptr ) :: conn interface function c_PQ_connect_start ( info ) bind ( c , name = \"PQconnectStart\" ) result ( conn ) import c_ptr , c_char implicit none character ( 1 , kind = c_char ), intent ( in ) :: info ( * ) type ( c_ptr ) :: conn end function c_PQ_connect_start end interface c_conninfo = conninfo // c_null_char conn = c_PQ_connect_start ( c_conninfo ) !*### Example !```Fortran !   character(:), allocatable :: conninfo !   type(c_ptr) :: conn !   integer :: res = -1 ! !   conninfo = \"host=localhost user=postgres dbname=postgres\" ! !   conn = PQconnectStart(conninfo) ! !   if (c_associated(conn)) then !      do while(res /= PGRES_POLLING_OK) ! loop for polling ! !         res = PQconnectPoll(conn) !         select case (res) !         case (PGRES_POLLING_FAILED) !            print *, PQerrorMessage(conn) !            error stop !         case (PGRES_POLLING_OK) !            print *, \"CONNECTION ESTABLISHED\" !            exit !         case default !            continue !            ! write some process here! !         end select ! !      end do !   else !      print *, \"Cannot connect the server.\" !      error stop !   end if !``` !*### References ! cf. [[PQconnectPoll]], [[PQconnectStartParams]] !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS) end function PQconnectStart !> Connect to the database server in a nonblocking manner. function PQconnectPoll ( conn ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding type ( c_ptr ) :: conn integer ( int32 ) :: PQconnectPoll interface function c_PQ_connect_poll ( conn ) bind ( c , name = \"PQconnectPoll\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_connect_poll end function c_PQ_connect_poll end interface PQconnectPoll = c_PQ_connect_poll ( conn ) !*### References ! cf. [[PQconnectStart]], [[PQconnectStartParams]] !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS) end function PQconnectPoll !> Get the default connection options. subroutine PQconndefaults ( options ) use :: PQconninfoOption_t use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( PQconninfoOption ), dimension (:), allocatable , target , intent ( out ) :: options interface function c_PQ_conndefaults_prepare ( optionsizes ) bind ( c , name = \"PQconndefaultsPrepare\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( out ) :: optionsizes integer ( c_int ) :: c_PQ_conndefaults_prepare end function c_PQ_conndefaults_prepare end interface interface function c_PQ_conndefaults () bind ( c , name = \"PQconndefaults\" ) import c_ptr implicit none type ( c_ptr ) :: c_PQ_conndefaults end function end interface interface subroutine c_PQ_conndefault_prepare_free ( cptr ) bind ( c , name = \"PQconndefaultPrepareFree\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: cptr end subroutine end interface type ( c_ptr ) :: cptr_siz , cptr_obj type ( c_PQconnOptionSizes ), dimension (:), pointer :: fptr type ( c_PQconninfoOption ), dimension (:), pointer :: opts_ptr integer :: length , i length = c_PQ_conndefaults_prepare ( cptr_siz ) call c_f_pointer ( cptr_siz , fptr , shape = [ length ]) cptr_obj = c_PQ_conndefaults () call c_f_pointer ( cptr_obj , opts_ptr , shape = [ length ]) allocate ( options ( length )) do i = 1 , length call read_option ( fptr ( i ), opts_ptr ( i ), options ( i )) end do call c_PQ_conndefault_prepare_free ( cptr_siz ) call PQconninfoFree ( cptr_obj ) !*### Example !```Fortran ! !   type(PQconninfoOption), allocatable, target :: options(:) !   integer :: i ! !   call PQconndefaults(options) ! !   ! Print the entire default options separated by colons !   do i = 1, size(options) !      print '(12a, i0)', trim(options(i)%keyword),\" : \", & !         trim(options(i)%envvar), \" : \", & !         trim(options(i)%compiled), \" : \", & !         trim(options(i)%val), \" : \", & !         trim(options(i)%label), \" : \", & !         trim(options(i)%dispchar), \" : \", & !         options(i)%dispsize !   end do !``` !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNDEFAULTS) end subroutine PQconndefaults subroutine PQconninfo ( conn , options ) use :: character_operations_m use :: PQconninfoOption_t use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn type ( PQconninfoOption ), dimension (:), allocatable , target , intent ( out ) :: options interface function c_PQ_conninfo_prepare ( conn , optionsizes ) bind ( c , name = \"PQconninfoPrepare\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ), intent ( out ) :: optionsizes integer ( c_int ) :: res end function c_PQ_conninfo_prepare end interface interface function c_PQ_conninfo ( conn ) bind ( c , name = \"PQconninfo\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_conninfo end function c_PQ_conninfo end interface interface subroutine c_PQ_conninfo_prepare_free ( cptr ) bind ( c , name = \"PQconninfoPrepareFree\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: cptr end subroutine end interface type ( c_ptr ) :: cptr_siz , cptr_obj type ( c_PQconnOptionSizes ), dimension (:), pointer :: fptr type ( c_PQconninfoOption ), dimension (:), pointer :: opts_ptr integer :: length , i length = c_PQ_conninfo_prepare ( conn , cptr_siz ) call c_f_pointer ( cptr_siz , fptr , shape = [ length ]) cptr_obj = c_PQ_conninfo ( conn ) call c_f_pointer ( cptr_obj , opts_ptr , shape = [ length ]) allocate ( options ( length )) do i = 1 , length call read_option ( fptr ( i ), opts_ptr ( i ), options ( i )) end do call c_PQ_conninfo_prepare_free ( cptr_siz ) call PQconninfoFree ( cptr_obj ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNINFO) end subroutine PQconninfo subroutine PQconninfoParse ( conninfo , options , errmsg , errflag ) use :: PQconninfoOption_t use :: character_operations_m use , intrinsic :: iso_c_binding implicit none character ( * ), intent ( in ) :: conninfo character ( * ), intent ( out ) :: errmsg character (:, kind = c_char ), allocatable :: c_conninfo type ( PQconninfoOption ), dimension (:), allocatable , target , intent ( out ) :: options type ( c_ptr ) :: cptr_siz , cptr_obj , cptr_errmsg type ( c_PQconnOptionSizes ), dimension (:), pointer :: fptr type ( c_PQconninfoOption ), dimension (:), pointer :: opts_ptr logical :: errflag integer :: length , i , errlen interface function c_PQ_conninfo_parse_prepare ( info , errmsg , errlen , optionsizes ) & bind ( c , name = \"PQconninfoParsePrepare\" ) import c_ptr , c_char , c_int implicit none character ( 1 , kind = c_char ), intent ( in ) :: info ( * ) type ( c_ptr ), intent ( inout ) :: errmsg integer ( c_int ), intent ( out ) :: errlen type ( c_ptr ), intent ( out ) :: optionsizes integer ( c_int ) :: c_PQ_conninfo_parse_prepare end function c_PQ_conninfo_parse_prepare end interface interface function c_PQ_conninfo_parse ( info , errmsg ) bind ( c , name = \"PQconninfoParse\" ) import c_ptr , c_char implicit none character ( 1 , kind = c_char ), intent ( in ) :: info ( * ) type ( c_ptr ) :: errmsg type ( c_ptr ) :: c_PQ_conninfo_parse end function c_PQ_conninfo_parse end interface interface subroutine c_PQ_conninfo_parse_free ( cptr ) bind ( c , name = \"PQconninfoParsePrepareFree\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: cptr end subroutine c_PQ_conninfo_parse_free end interface ! エラーフラグを初期化する。 errflag = . false . errlen = 0 ! C文字列へ変換してCの関数を呼び出す。 c_conninfo = trim ( conninfo ) // c_null_char length = c_PQ_conninfo_parse_prepare ( c_conninfo , cptr_errmsg , errlen , cptr_siz ) !　エラーメッセージが返された場合 if (. not . c_associated ( cptr_siz )) then block character ( errlen ), pointer :: fptr_errmsg call c_f_pointer ( cptr_errmsg , fptr_errmsg ) if ( associated ( fptr_errmsg )) then ! errlen-1は末尾の改行を含めないため。 errmsg = fptr_errmsg ( 1 : errlen - 1 ) end if end block errflag = . true . return end if ! Cから返されたポインタをFortranのポインタに関連付ける。 call c_f_pointer ( cptr_siz , fptr , shape = [ length ]) ! 関数c_PQ_conninfo_parseを呼び出して、結果をcptr_objに格納する。ここでのエラーメッセージは捨てる。 block type ( c_ptr ) :: trush cptr_obj = c_PQ_conninfo_parse ( c_conninfo , trush ) end block ! Cから返されたポインタをFortranポインタに関連付ける。 call c_f_pointer ( cptr_obj , opts_ptr , shape = [ length ]) ! オプション情報を配列optionsにコピーする。 allocate ( options ( length )) do i = 1 , length call read_option ( fptr ( i ), opts_ptr ( i ), options ( i )) end do ! 使用済みメモリを解放する。 call c_PQ_conninfo_parse_free ( cptr_siz ) call PQconninfoFree ( cptr_obj ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQCONNINFOPARSE) end subroutine PQconninfoParse ! subroutine PQconninfoFree ( connopts ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: connopts interface subroutine c_PQ_conninfo_free ( connOptions ) bind ( c , name = \"PQconninfoFree\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: connOptions end subroutine c_PQ_conninfo_free end interface call c_PQ_conninfo_free ( connopts ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQCONNINFOFREE) end subroutine PQconninfoFree subroutine PQfinish ( conn ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( inout ) :: conn interface ! Interface ot PQfinish in interfaces/libpq/fe-connect.c: ! ! void PQfinish(PGconn *conn) subroutine c_PQ_finish ( conn ) bind ( c , name = 'PQfinish' ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn end subroutine c_PQ_finish end interface call c_PQ_finish ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQFINISH) end subroutine PQfinish subroutine PQreset ( conn ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( inout ) :: conn interface subroutine c_PQ_reset ( conn ) bind ( c , name = 'PQreset' ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn end subroutine c_PQ_reset end interface call c_PQ_reset ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQRESET) end subroutine PQreset function PQresetStart ( conn ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: PQresetStart interface function c_PQ_reset_start ( conn ) bind ( c , name = \"PQresetStart\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_reset_start end function c_PQ_reset_start end interface PQresetStart = c_PQ_reset_start ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQRESETSTART) end function PQresetStart function PQresetPoll ( conn ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: PQresetPoll interface function c_PQ_reset_poll ( conn ) bind ( c , name = \"PQresetPoll\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_reset_poll end function c_PQ_reset_poll end interface PQresetPoll = c_PQ_reset_poll ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQRESETSTART) end function PQresetPoll function PQpingParams ( keywords , values , expand_dbname ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none character ( * ), intent ( in ) :: keywords (:) character ( * ), intent ( in ) :: values (:) integer , intent ( in ) :: expand_dbname integer ( c_int ) :: res integer :: max_len_key , max_len_val interface function c_PQ_ping_params ( keywords , values , expand_dbname ) & bind ( c , name = \"PQpingParams\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: keywords type ( c_ptr ), intent ( in ), value :: values integer ( c_int ), intent ( in ) :: expand_dbname integer ( c_int ) :: c_PQ_ping_params end function c_PQ_ping_params end interface max_len_key = max_length_char_array ( keywords ) max_len_val = max_length_char_array ( values ) block character ( max_len_key + 1 , kind = c_char ), allocatable , target :: c_keys (:) character ( max_len_val + 1 , kind = c_char ), allocatable , target :: c_values (:) type ( c_ptr ), allocatable , target :: ptr_keys (:) type ( c_ptr ), allocatable , target :: ptr_values (:) integer ( c_int ) :: c_expand_dbname call cchar_array_from_strings ( keywords , c_keys , max_len_key ) call cptr_array_from_cchar ( c_keys , ptr_keys ) call cchar_array_from_strings ( values , c_values , max_len_val ) call cptr_array_from_cchar ( c_values , ptr_values ) c_expand_dbname = expand_dbname res = c_PQ_ping_params ( c_loc ( ptr_keys ( 1 )), c_loc ( ptr_values ( 1 )), c_expand_dbname ) end block !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQPINGPARAMS) end function PQpingParams function PQping ( conninfo ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none character ( * ), intent ( in ) :: conninfo character (:, kind = c_char ), allocatable :: c_conninfo integer ( int32 ) :: res interface function c_PQ_ping ( info ) bind ( c , name = \"PQping\" ) result ( c_res ) import c_char , c_int implicit none character ( 1 , kind = c_char ), intent ( in ) :: info ( * ) integer ( c_int ) :: c_res end function c_PQ_ping end interface c_conninfo = conninfo // c_null_char res = c_PQ_ping ( c_conninfo ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PQPING) end function PQping ! function PQsetSSLKeyPassHook_OpenSSL ! function PQgetSSLKeyPassHook_OpenSSL !==================================================================! ! Connection Status Functions function PQdb ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res ! Interface PQdb in src/interfaces/fe-connection.c interface function c_PQ_db ( conn ) bind ( c , name = \"PQdb\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_db end function c_PQ_db end interface res => c_to_f_charpointer ( c_PQ_db ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQDB) end function PQdb function PQuser ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res ! Interface PQuserin src/interfaces/fe-connection.c interface function c_PQ_user ( conn ) bind ( c , name = \"PQuser\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_user end function c_PQ_user end interface res => c_to_f_charpointer ( c_PQ_user ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQUSER) end function PQuser function PQpass ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res interface function c_PQ_pass ( conn ) bind ( c , name = \"PQpass\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_pass end function c_PQ_pass end interface res => c_to_f_charpointer ( c_PQ_pass ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQPASS) end function PQpass function PQhost ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res ! Interface PQhost in src/interfaces/fe-connection.c interface function c_PQ_host ( conn ) bind ( c , name = \"PQhost\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_host end function c_PQ_host end interface res => c_to_f_charpointer ( c_PQ_host ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQHOST) end function PQhost function PQhostaddr ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res ! Interface PQhostaddr in src/interfaces/fe-connection.c interface function c_PQ_hostaddr ( conn ) bind ( c , name = \"PQhostaddr\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_hostaddr end function c_PQ_hostaddr end interface res => c_to_f_charpointer ( c_PQ_hostaddr ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQHOSTADDR) end function PQhostaddr function PQport ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res interface function c_PQ_port ( conn ) bind ( c , name = \"PQport\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_port end function c_PQ_port end interface res => c_to_f_charpointer ( c_PQ_port ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQPORT) end function PQport function PQoptions ( conn ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:), pointer :: res ! Interface PQoptions in src/interface/fe-connection.c interface function c_PQ_options ( conn ) bind ( c , name = \"PQoptions\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_options end function c_PQ_options end interface res => c_to_f_charpointer ( c_PQ_options ( conn )) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQOPTIONS) end function PQoptions function PQstatus ( conn ) result ( res ) use , intrinsic :: iso_fortran_env , only : int32 use , intrinsic :: iso_c_binding , only : c_ptr , c_int implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface ! Interface to PQstatus in interface/libpq/fe-connect.c: ! ! ConnStatusType PQstatus(const PGconn *conn) function c_PQ_status ( conn ) bind ( c , name = 'PQstatus' ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: res end function c_PQ_status end interface res = c_PQ_status ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSTATUS) end function PQstatus function PQtransactionStatus ( conn ) result ( res ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer ( c_int ) :: res interface function c_PQ_transaction_status ( conn ) & bind ( c , name = \"PQtransactionStatus\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: res end function c_PQ_transaction_status end interface res = c_PQ_transaction_status ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQTRANSACTIONSTATUS) end function PQtransactionStatus function PQparameterStatus ( conn , paramName ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: paramName character (:), allocatable :: c_paramName character (:), pointer :: PQparameterStatus interface function c_PQ_parameter_status ( conn , param_name ) bind ( c , name = \"PQparameterStatus\" ) import c_ptr , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: param_name ( * ) type ( c_ptr ) :: c_PQ_parameter_status end function c_PQ_parameter_status end interface c_paramName = trim ( adjustl ( paramName )) // c_null_char PQparameterStatus => c_to_f_charpointer ( c_PQ_parameter_status ( conn , c_paramName )) if (. not . associated ( PQparameterStatus )) then PQparameterStatus = '' end if !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQPARAMETERSTATUS) end function PQparameterStatus function PQprotocolVersion ( conn ) result ( res ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer :: res interface function c_PQ_protocol_version ( conn ) bind ( c , name = \"PQprotocolVersion\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_protocol_version end function c_PQ_protocol_version end interface res = c_PQ_protocol_version ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQPROTOCOLVERSION) end function PQprotocolVersion function PQserverVersion ( conn ) result ( res ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer :: res interface function c_PQ_server_version ( conn ) bind ( c , name = \"PQserverVersion\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_server_version end function c_PQ_server_version end interface res = c_PQ_server_version ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSERVERVERSION) end function PQserverVersion !>> Returns the error message most recently generated by an operation on the connection. !> function PQerrorMessage ( conn ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character (:, c_char ), pointer :: PQerrormessage interface ! Interface to PQerrorMessage in interfaces/libpq/fe-connect.c: ! ! char *PQerrorMessage(const PGconn *conn) function c_PQ_error_message ( conn ) bind ( c , name = 'PQerrorMessage' ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_error_message end function c_PQ_error_message end interface PQerrormessage => c_to_f_charpointer ( c_PQ_error_message ( conn )) !*> Nearly all libpq functions will set a message for `PQerrorMessage` if they fail. ! > Note that by libpq convention, a nonempty `PQerrorMessage` result can consist of multiple lines, ! > and will include a trailing newline. The caller should not free the result directly. ! > It will be freed when the associated PGconn handle is passed to `[[PQfinish]]`. ! > The result string should not be expected to remain the same across operations on the `PGconn` structure. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQERRORMESSAGE) end function PQerrorMessage !>> Obtain the file descriptor number of the connection socket to the server. !>> function PQsocket ( conn ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer ( c_int ) :: PQsocket interface function c_PQ_socket ( conn ) bind ( c , name = \"PQsocket\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_socket end function c_PQ_socket end interface PQsocket = c_PQ_socket ( conn ) !*> A valid descriptor will be greater than or equal to 0; a result of -1 indicates that no server connection is ! > currently open. (This will not change during normal operation, but could change during connection set up or ! > reset.) ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSOCKET) end function PQsocket function PQbackendPID ( conn ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn integer ( c_int ) :: PQbackendPID interface function c_PQ_backend_pid ( conn ) bind ( c , name = \"PQbackendPID\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_backend_pid end function c_PQ_backend_pid end interface PQbackendPID = c_PQ_backend_pid ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQBACKENDPID) end function PQbackendPID function PQconnectionNeedsPassword ( conn ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: PQconnectionNeedsPassword interface function c_PQ_connection_needs_password ( conn ) & bind ( c , name = \"PQconnectionNeedsPassword\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: res end function c_PQ_connection_needs_password end interface PQconnectionNeedsPassword = c_PQ_connection_needs_password ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQCONNECTIONNEEDSPASSWORD) end function PQconnectionNeedsPassword function PQconnectionUsedPassword ( conn ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: PQconnectionUsedPassword interface function c_PQ_connection_used_password ( conn ) & bind ( c , name = \"PQconnectionUsedPassword\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: res end function c_PQ_connection_used_password end interface PQconnectionUsedPassword = c_PQ_connection_used_password ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQCONNECTIONUSEDPASSWORD) end function PQconnectionUsedPassword != for SSL connection function PQsslInUse ( conn ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn logical :: PQsslInUse integer ( int32 ) :: res interface function c_PQ_ssl_in_use ( conn ) bind ( c , name = \"PQsslInUse\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_ssl_in_use end function c_PQ_ssl_in_use end interface res = c_PQ_ssl_in_use ( conn ) if ( res == 1 ) then PQsslInUse = . true . else if ( res == 0 ) then PQsslInUse = . false . end if !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSSLINUSE) end function PQsslInUse subroutine PQsslAttribute ( conn , attribute_name , resultstr ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: character_operations_m implicit none ! Input parameters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: attribute_name ! Output pointer character (:), allocatable :: resultstr ! Local variables character (:, kind = c_char ), allocatable :: c_attribute_name character (:), allocatable :: buff type ( c_ptr ) :: cptr interface function c_PQ_ssl_attribute ( conn , attribute_name ) bind ( c , name = \"PQsslAttribute\" ) import c_ptr , c_char type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: attribute_name type ( c_ptr ) :: c_PQ_ssl_attribute end function c_PQ_ssl_attribute end interface c_attribute_name = trim ( adjustl ( attribute_name )) // c_null_char cptr = c_PQ_ssl_attribute ( conn , c_attribute_name ) if ( c_associated ( cptr )) then call c_char_to_f_string ( cptr , buff ) resultstr = buff else resultstr = '' end if !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSSLATTRIBUTE) end subroutine PQsslAttribute !> Subroutine for retrieving SSL attribute names from a PostgreSQL !> database connection and populating an array. ! Input: !  - 'conn' is the connection pointer, !  - 'len' is the length of the element of the output string array. ! Output: !  - 'strings' must be a one-dimensional array of uninitialized !    strings that will be allocated in this subroutine. ! subroutine PQsslAttributeNames ( conn , strings , len ) !!@bug This doesn't work in the GCC 11.4.0 environment. @endbug use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: character_operations_m implicit none ! Input Parameters type ( c_ptr ), intent ( in ) :: conn integer ( int32 ), intent ( in ) :: len character ( len ), allocatable :: strings (:) ! Interfaces to functions in src/wraps/PQsslAttributeNamesWrap.c interface function c_PQ_ssl_Attribute_Names_Prepare_Size ( conn ) & bind ( c , name = \"PQsslAttributeNamesPrepareSize\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_ssl_Attribute_Names_Prepare_Size end function c_PQ_ssl_Attribute_Names_Prepare_Size end interface interface subroutine c_PQ_ssl_Attribute_Names_Prepare_Lengths ( conn , array ) & bind ( c , name = \"PQsslAttributeNamesPrepareLengths\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: array (:) end subroutine c_PQ_ssl_Attribute_Names_Prepare_Lengths end interface ! Interface to libpq function PQsslAttriubteNames interface function c_PQ_ssl_Attribute_Names_Wraped ( conn ) bind ( c , name = \"PQsslAttributeNames\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_ssl_Attribute_Names_Wraped end function c_PQ_ssl_Attribute_Names_Wraped end interface ! Local variables integer ( int32 ) :: siz ! Size of the attribute names array integer ( int32 ), allocatable :: lengths (:) ! Array to store lengths type ( c_ptr ) :: ptr ! Pointer to the attribute names array ! Get the size of the attribute names array using C funciton. siz = c_PQ_ssl_Attribute_Names_Prepare_Size ( conn ) ! Allocate memory for the lengths array and the strings array. allocate ( lengths ( siz )) allocate ( strings ( siz )) ! Get the lengths of attribute name strings using C funciton. call c_PQ_ssl_Attribute_Names_Prepare_Lengths ( conn , lengths ) ! Get a pointer to the attribute names array using PostgreSQL function. ptr = c_PQ_ssl_Attribute_Names_Wraped ( conn ) ! If the pointer is not associated, exit. if (. not . c_associated ( ptr )) then deallocate ( lengths ) return end if ! Process strings within a block block character (:), pointer :: strptr ! Temporary string pointer type ( c_ptr ), dimension (:), pointer :: ptr_array ! Array of pointers integer ( int32 ) :: i ! Associate the poninter with a Fortran array call c_f_pointer ( ptr , ptr_array , shape = [ siz ]) do i = 1 , siz ! Convert the pointer to a Fortran character pointer with its length. strptr => c_to_f_charpointer_with_length ( ptr_array ( i ), lengths ( i )) ! Store the string in the strings array. strings ( i ) = strptr (:) end do end block deallocate ( lengths ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-status.html#LIBPQ-PQSSLATTRIBUTENAMES) end subroutine PQsslAttributeNames ! function PQsslStruct !==================================================================! !== Canceling Queries in Progress function PQgetCancel ( conn ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn type ( c_ptr ) :: PQgetCancel interface function c_PQ_get_cancel ( conn ) bind ( c , name = \"PQgetCancel\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_get_cancel end function c_PQ_get_cancel end interface PQgetCancel = c_PQ_get_cancel ( conn ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-cancel.html#LIBPQ-PQGETCANCEL) end function PQgetCancel subroutine PQfreeCancel ( cancel ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: cancel interface subroutine c_PQ_free_cancel ( cancel ) bind ( c , name = \"PQfreeCancel\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: cancel end subroutine end interface call c_PQ_free_cancel ( cancel ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-cancel.html#LIBPQ-PQFREECANCEL) end subroutine PQfreeCancel function PQcancel ( cancel , errbuf , errbufsize ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none ! Input parameters type ( c_ptr ), intent ( in ) :: cancel character ( * ), intent ( inout ) :: errbuf integer ( int32 ), intent ( in ) :: errbufsize ! Output integer integer ( int32 ) :: PQcancel ! Local variables character ( len = 256 , kind = c_char ), target :: c_errbuf interface function c_PQ_cancel ( cancel , errbuf , errbufsize ) bind ( c , name = \"PQcancel\" ) import c_int , c_ptr , c_char implicit none type ( c_ptr ), intent ( in ), value :: cancel type ( c_ptr ), intent ( in ), value :: errbuf integer ( c_int ), intent ( in ), value :: errbufsize integer ( c_int ) :: c_PQ_cancel end function c_PQ_cancel end interface c_errbuf = '' PQcancel = c_PQ_cancel ( cancel , c_loc ( c_errbuf ), 256 ) errbuf = c_errbuf ( 1 : errbufsize ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-cancel.html#LIBPQ-PQCANCEL) end function PQcancel !==================================================================! !== Control Functions function PQclientEncoding ( conn ) result ( res ) use character_operations_m use fe_exec_m , only : PQfreemem use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env ! Input parameter type ( c_ptr ), intent ( in ) :: conn ! Declare Result pointer character (:), pointer :: res ! Declare local variables character (:), allocatable , target , save :: encoding integer ( c_int ) :: encoding_id type ( c_ptr ) :: cptr ! Define an interface for the C func. that retrieves the clinent encoding id. interface function c_PQ_client_encoding ( conn ) bind ( c , name = \"PQclientEncoding\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_client_encoding end function c_PQ_client_encoding end interface ! Define an interface for the C func. that converts encoding-id to a character string. interface function c_pg_encoding_to_char ( encoding_id ) bind ( c , name = \"pg_encoding_to_char\" ) import c_ptr , c_int integer ( c_int ), intent ( in ), value :: encoding_id type ( c_ptr ) :: c_pg_encoding_to_char end function c_pg_encoding_to_char end interface ! Initialize the result pointer to null. nullify ( res ) ! Call the C function to retrieve the client encoding id. encoding_id = c_PQ_client_encoding ( conn ) ! If the returned value is -1, return without setting the result (indicating an error). if ( encoding_id == - 1 ) return ! Call the C function to convert the encoding id to a character string (c_ptr) cptr = c_pg_encoding_to_char ( encoding_id ) ! Convert the C string to a Fortran string and assign it to the result. call c_char_to_f_string ( cptr , encoding ) res => encoding !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-control.html#LIBPQ-PQCLIENTENCODING) end function function PQsetClientEncoding ( conn , encoding ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: encoding integer ( int32 ) :: res character (:, kind = c_char ), allocatable :: c_encoding interface function c_PQ_set_client_encoding ( conn , encoding ) bind ( c , name = \"PQsetClientEncoding\" ) import c_ptr , c_char , c_int type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: encoding ( * ) integer ( c_int ) :: c_PQ_set_client_encoding end function c_PQ_set_client_encoding end interface c_encoding = trim ( encoding ) // c_null_char res = c_PQ_set_client_encoding ( conn , c_encoding ) !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-control.html#LIBPQ-PQSETCLIENTENCODING) end function PQsetClientEncoding function PQsetErrorVerbosity ( conn , verbosity ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: enumerators_t implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ), intent ( in ) :: verbosity integer ( int32 ) :: res interface function c_PQ_set_Error_Verbosity ( conn , verbosity ) bind ( c , name = \"PQsetErrorVerbosity\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ), intent ( in ), value :: verbosity integer ( c_int ) :: c_PQ_set_error_verbosity end function c_PQ_set_error_verbosity end interface select case ( verbosity ) case ( PQERRORS_TERSE ) res = c_PQ_set_Error_Verbosity ( conn , PQERRORS_TERSE ) case ( PQERRORS_DEFAULT ) res = c_PQ_set_Error_Verbosity ( conn , PQERRORS_DEFAULT ) case ( PQERRORS_VERBOSE ) res = c_PQ_set_Error_Verbosity ( conn , PQERRORS_VERBOSE ) case ( PQERRORS_SQLSTATE ) res = c_PQ_set_Error_Verbosity ( conn , PQERRORS_SQLSTATE ) case default res = - 1 end select !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-control.html#LIBPQ-PQSETERRORVERBOSITY) end function PQsetErrorVerbosity function PQsetErrorContextVisibility ( conn , show_context ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: enumerators_t implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ), intent ( in ) :: show_context integer ( int32 ) :: res interface function c_PQ_set_error_context_visibility ( conn , show_context ) & bind ( c , name = \"PQsetErrorContextVisibility\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ), intent ( in ), value :: show_context integer ( c_int ) :: c_PQ_set_error_context_visibility end function end interface select case ( show_context ) case ( PQSHOW_CONTEXT_NEVER ) res = c_PQ_set_error_context_visibility ( conn , PQSHOW_CONTEXT_NEVER ) case ( PQSHOW_CONTEXT_ERRORS ) res = c_PQ_set_error_context_visibility ( conn , PQSHOW_CONTEXT_ERRORS ) case ( PQSHOW_CONTEXT_ALWAYS ) res = c_PQ_set_error_context_visibility ( conn , PQSHOW_CONTEXT_ALWAYS ) case default res = - 1 end select !* cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-control.html#LIBPQ-PQSETERRORCONTEXTVISIBILITY) end function PQsetErrorContextVisibility end module fe_connect_m","tags":"","loc":"sourcefile/fe-connect.f90.html"},{"title":"fe-auth.f90 – Libpq-Fortran","text":"Contents Modules fe_auth_m Source Code fe-auth.f90 Source Code module fe_auth_m implicit none private public :: PQencryptPasswordConn contains ! This subroutine encrypts a password using PostgreSQL's PQencryptPasswordConn. ! Inputs: !   - conn: PostgreSQL connection pointer !   - passwd: Password to be encrypted !   - user: User associated with the password !   - algorithm: Encryption algorithm to use ('md5' or 'scram-sha-256') ! Output: !   - encrypted: Encrypted password subroutine PQencryptPasswordConn ( conn , passwd , user , algorithm , encrypted ) use :: character_operations_m use :: fe_exec_m use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none ! Input paramters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: passwd character ( * ), intent ( in ) :: user character ( * ), intent ( in ) :: algorithm character ( * ), intent ( out ) :: encrypted ! Local variables character (:), allocatable :: buff type ( c_ptr ) :: cptr character (:, kind = c_char ), allocatable , target :: c_passwd , c_user , c_algorithm interface function c_PQ_encrypt_password_conn ( conn , passwd , user , algorithm ) bind ( c , name = \"PQencryptPasswordConn\" ) import c_ptr , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: passwd ( * ) character ( 1 , kind = c_char ), intent ( in ) :: user ( * ) character ( 1 , kind = c_char ), intent ( in ) :: algorithm ( * ) type ( c_ptr ) :: c_PQ_encrypt_password_conn end function c_PQ_encrypt_password_conn end interface ! Initialize 'encrypted'. encrypted = '' ! Convert Fortran strings to C-style strings. c_passwd = trim ( adjustl ( passwd )) // c_null_char c_user = trim ( adjustl ( user )) // c_null_char c_algorithm = trim ( adjustl ( algorithm )) // c_null_char ! Call the C function to encrypt the password. cptr = c_PQ_encrypt_password_conn ( conn , c_passwd , c_user , c_algorithm ) ! Convert the C result to Fortran string. call c_char_to_f_string ( cptr , buff ) ! Store the encrypted password. encrypted = buff ! Free the C memory call PQfreemem ( cptr ) end subroutine PQencryptPasswordConn end module fe_auth_m","tags":"","loc":"sourcefile/fe-auth.f90.html"},{"title":"fe-misc.f90 – Libpq-Fortran","text":"Contents Modules fe_misc_m Source Code fe-misc.f90 Source Code module fe_misc_m implicit none private public :: PQlibVersion contains !> Get the current running version of libpq. integer function PQlibVersion () use , intrinsic :: iso_c_binding interface function c_PQ_lib_version () bind ( c , name = \"PQlibVersion\" ) import c_int implicit none integer ( c_int ) :: c_PQ_lib_version end function c_PQ_lib_version end interface PQlibVersion = c_PQ_lib_version () !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQLIBVERSION) end function PQlibVersion end module fe_misc_m","tags":"","loc":"sourcefile/fe-misc.f90.html"},{"title":"fe-exec.f90 – Libpq-Fortran","text":"Contents Modules fe_exec_m Source Code fe-exec.f90 Source Code module fe_exec_m implicit none private public :: PQexec public :: PQresultStatus public :: PQresultErrorMessage public :: PQresultVerboseErrorMessage public :: PQgetvalue public :: PQntuples public :: PQnfields public :: PQfname public :: PQfnumber public :: PQclear public :: PQgetisnull public :: PQfreemem public :: PQbinaryTuples public :: PQfformat public :: PQfmod public :: PQfsize public :: PQftablecol public :: PQftable public :: PQftype public :: PQresStatus public :: PQgetlength public :: PQnparams public :: PQparamtype public :: PQresultErrorField public :: PQcmdStatus public :: PQcmdTuples public :: PQoidValue public :: PQsendQuery public :: PQgetResult public :: PQconsumeInput public :: PQisBusy public :: PQsetnonblocking public :: PQisnonblocking public :: PQflush public :: PQescapeLiteral public :: PQescapeIdentifier public :: PQexecParams interface PQexecParams module procedure :: PQexecParams_int32 module procedure :: PQexecParams_int64 end interface public :: PQprepare interface PQprepare module procedure :: PQprepare_int32 module procedure :: PQprepare_int64 end interface public :: PQexecPrepared public :: PQdescribePrepared public :: PQdescribePortal public :: PQsendPrepare interface PQsendPrepare module procedure :: PQsendPrepare_int32 module procedure :: PQsendPrepare_int64 end interface public :: PQsendQueryPrepared interface PQsendQueryPrepared module procedure :: PQsendQueryPrepared_text end interface public :: PQsendDescribePrepared public :: PQsendDescribePortal public :: PQpipelineStatus public :: PQenterPipelineMode public :: PQexitPipelineMode public :: PQpipelineSync public :: PQsendFlushRequest public :: PQsetSingleRowMode public :: PQsendQueryParams interface PQsendQueryParams module procedure :: PQsendQueryParams_int32 module procedure :: PQsendQueryParams_int64 end interface public :: PQisthreadsafe public :: PQmakeEmptyPGresult public :: PQcopyResult public :: PQnotifies contains !==================================================================! !== Command Execution Functions !== Main Functions !> Send query to the server and wait until receiving the result. function PQexec ( conn , query ) result ( res ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: query character (:, kind = c_char ), allocatable :: c_query type ( c_ptr ) :: res interface ! Interface to PQexec in interfaces/libpq/fe-exec.c: ! ! PGresult *PQexec(PGconn *conn, const char *query) ! function c_PQ_exec ( conn , query ) bind ( c , name = 'PQexec' ) result ( pgresult ) import c_ptr , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn ! To pass a string to C, declare an array of type 'character' with kind 'c_char'. character ( 1 , kind = c_char ), intent ( in ) :: query ( * ) type ( c_ptr ) :: pgresult end function c_PQ_exec end interface ! Append a C null character to the end of the query. c_query = query // c_null_char res = c_PQ_exec ( conn , c_query ) !|> Submit a command to the server and waits for the result. ! > ! > Returns a `PGresult` pointer or possibly a null pointer. ! > A non-null pointer will generally be returned except in out-of-memory conditions or ! > serious errors such as inability to send the command to the server. ! > The `[[PQresultStatus]]` function should be called to check the return value for any errors ! > (including the value of a null pointer, in which case it will return PGRES_FATAL_ERROR). ! > Use `[[PQerrorMessage]]` to get more information about such errors. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXEC) !*### Example !```Fortran ! type(c_ptr) :: conn, res ! integer :: stat ! ! conn = PQconnectdb(\"dbname=postgres\") ! !...error handling... ! ! res = PQexec(conn, \"select 1234;\") ! stat = PQresultStatus(res) ! if (stat /= PGRES_COMMAND_OK .and. stat /= PGRES_TUPLES_OK) then !    print *, PQerrorMessage(conn) !    call PQclear(res) !    call PQfinish(conn) !    error stop ! end if ! ! ! ... some statements ... ! call PQclear(res) !``` end function PQexec ! Only TEXT format for now ! a version of int32 for paramTypes function PQexecParams_int32 ( conn , command , nParams , paramTypes , paramValues ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned use :: character_operations_m implicit none !*> Submits a command to the server and waits for the result, with the ability to pass ! > parameters separately from the SQL command text. ! > ! > `PQexecParams` is like [`PQexec`](../proc/pqexec.html) but offers additional functionality: ! > parameter values can be specified separately from the command string proper, and query results ! > can be requested in text or binary format. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPARAMS) !!@note Binary format have not been implemented yet. !*### Example !```fortran ! block !    character(:), allocatable :: command !    character(8) :: values(2) !    type(c_ptr) :: res ! !    command = \"select $1::bigint + $2::bigint;\" !    values(1) = \"300\" !    values(2) = \"500\" ! !    res = PQexecParams(conn, command, size(values), [0, 0], values) !    if (PQresultStatus(res) /= PGRES_TUPLES_OK) then !       print *, PQerrorMessage(conn) !       call PQclear(res) !    end if ! !    print *, PQgetvalue(res, 0, 0) ! the result \"800\" is expected. !    call PQclear(res) !``` ! Input parameters !> The connection object to send the command through. type ( c_ptr ), intent ( in ) :: conn !> The SQL command string to be executed. If parameters are used, !> they are referred to in the command string as `$1`, `$2`, etc. character ( * ), intent ( in ) :: command !> The number of parameters supplied; it is the length of the arrays `paramTypes`, !> `paramValues`. integer ( int32 ), intent ( in ) :: nParams !> Specifies, by OID, the data types to be assigned to the parameter symbols. !> If any particular element in the array is zero, the server infers a data type !> for the parameter symbol in the same way it would do for an untyped literal string. integer ( int32 ), intent ( in ) :: paramTypes (:) !> Specifies the actual values of the parameters. A empty string in this array means !> the corresponding parameter is null. character ( * ), intent ( in ) :: paramValues (:) ! paramValues(nParams) ! Output pgresult type ( c_ptr ) :: res ! Local variables integer :: i integer ( int64 ), allocatable :: paramTypes_i64 (:) allocate ( paramTypes_i64 ( size ( paramTypes , dim = 1 ))) do i = 1 , size ( paramTypes , dim = 1 ) paramTypes_i64 ( i ) = int ( paramTypes ( i ), int64 ) end do res = PQexecParams ( conn , command , nParams , paramTypes_i64 , paramValues ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPARAMS) end function PQexecParams_int32 ! Only TEXT format for now ! a version of int64 for paramTypes function PQexecParams_int64 ( conn , command , nParams , paramTypes , paramValues ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned use :: character_operations_m implicit none !*> Submits a command to the server and waits for the result, with the ability to pass ! > parameters separately from the SQL command text. ! > ! > `PQexecParams` is like [`PQexec`](../proc/pqexec.html) but offers additional functionality: ! > parameter values can be specified separately from the command string proper, and query results ! > can be requested in text or binary format. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPARAMS) !!@note Binary format have not been implemented yet. !*### Example !```fortran ! block !    character(:), allocatable :: command !    character(8) :: values(2) !    type(c_ptr) :: res ! !    command = \"select $1::bigint + $2::bigint;\" !    values(1) = \"300\" !    values(2) = \"500\" ! !    res = PQexecParams(conn, command, size(values), [0_8, 0_8], values) !    if (PQresultStatus(res) /= PGRES_TUPLES_OK) then !       print *, PQerrorMessage(conn) !       call PQclear(res) !    end if ! !    print *, PQgetvalue(res, 0, 0) ! the result \"800\" is expected. !    call PQclear(res) !``` ! Input parameters !> The connection object to send the command through. type ( c_ptr ), intent ( in ) :: conn !> The SQL command string to be executed. If parameters are used, !> they are referred to in the command string as `$1`, `$2`, etc. character ( * ), intent ( in ) :: command !> The number of parameters supplied; it is the length of the arrays `paramTypes`, !> `paramValues`. integer ( int32 ), intent ( in ) :: nParams !> Specifies, by OID, the data types to be assigned to the parameter symbols. !> If any particular element in the array is zero, the server infers a data type !> for the parameter symbol in the same way it would do for an untyped literal string. integer ( int64 ), intent ( in ) :: paramTypes (:) !> Specifies the actual values of the parameters. A empty string in this array means !> the corresponding parameter is null. character ( * ), intent ( in ) :: paramValues (:) ! paramValues(nParams) ! Output pgresult type ( c_ptr ) :: res ! Local variables character (:, kind = c_char ), allocatable :: c_command type ( uint32 ), allocatable , target :: c_paramtypes (:) integer :: resultFormat integer :: max_len_val integer :: i ! For nParams >= 1 interface function c_PQ_exec_parameters ( conn , command , nParams , paramTypes , paramValues , & paramLengths , paramFormats , resultFormat ) & bind ( c , name = \"PQexecParams\" ) import c_ptr , c_int , uint32 , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: command ( * ) ! String integer ( c_int ), intent ( in ), value :: nParams ! Int scalar type ( c_ptr ), intent ( in ), value :: paramTypes type ( c_ptr ), intent ( in ), value :: paramValues ! String array type ( c_ptr ), intent ( in ), value :: paramLengths ! Int array type ( c_ptr ), intent ( in ), value :: paramFormats ! Int array integer ( c_int ), intent ( in ), value :: resultFormat ! Int scalar type ( c_ptr ) :: c_PQ_exec_parameters end function c_PQ_exec_parameters end interface resultFormat = 0 ! text format only for now. c_command = trim ( command ) // c_null_char if ( nParams >= 1 ) then max_len_val = max_length_char_array ( paramValues ) allocate ( c_paramtypes ( nParams )) do i = 1 , nParams c_paramtypes ( i ) = paramTypes ( i ) end do block character ( max_len_val + 1 , kind = c_char ), allocatable , target :: c_values (:) type ( c_ptr ), allocatable , target :: ptr_values (:) call cchar_array_from_strings_no_null ( paramValues , c_values , max_len_val ) call cptr_array_from_cchar_no_null ( c_values , ptr_values ) res = c_PQ_exec_parameters (& conn , command , nParams , c_loc ( c_paramTypes ), & c_loc ( ptr_values ( 1 )), c_null_ptr , c_null_ptr , resultFormat ) ! for BINARY format ! res = c_PQ_exec_parameters(& ! conn, command, nParams, c_paramTypes, & ! ptr_values, paramLengths, paramFormats, resultFormat) end block deallocate ( c_paramtypes ) ! for nParams == 0 else if ( nParams == 0 ) then block type ( c_ptr ) :: null_paramTypes = c_null_ptr type ( c_ptr ) :: null_paramValues = c_null_ptr type ( c_ptr ) :: null_paramLength = c_null_ptr type ( c_ptr ) :: null_paramFormats = c_null_ptr res = c_PQ_exec_parameters (& conn , command , nParams , & null_paramTypes , & null_paramValues , & null_paramLength , & null_paramFormats , & resultFormat ) end block end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPARAMS) end function PQexecParams_int64 ! --- PQprepare frontend function PQprepare_int32 ( conn , stmtName , query , nParams , paramTypes ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned implicit none !*> Submits a request to create a prepared statement with the given parameters, and waits for completion. !*> `PQprepare` creates a prepared statement for later execution with `PQexecPrepared`. ! > This feature allows commands to be executed repeatedly without being parsed and ! > planned each time; see [PREPARE](https://www.postgresql.org/docs/current/sql-prepare.html) for details. !*> The function create a prepared statement named `stmtName` from the `query` string, which ! > must contain a single SQL command. `stmtName` can be `\"\"` to create an unnamed statement, ! > in which case any pre-existing unnamed statement is automatically replaced; otherwise it is ! > an error if the statement name is already defined in the current session. If any parameters are used, ! > they are referred to in the as `$1`, `$2`, etc. `nParams` is the number of parameters for which types ! > are pre-specified in the array `paramTypes`. ! > `paramTypes` specifies, by OID, the data types to be assigned to the parameter symbols. ! > If any particuler element in the `paramTypes` array is zero, the server assigns a data type to the ! > parameter symbol in the same way it would do for an untyped literal string. ! > Also, the query can use parameter symbols with the numbers higher than `nParams`; data types will ! > be inferred for these symbols as well. ! (See [PQdescribePrepared](../proc/pqdescribeprepared.html)) for a means to find out what data types were inffered.) !*> As with `[[PQexec]]`, the result is normally a `PGresult` object whose contents indicate server-side ! > success or failure. A null result indicates out-of-memory or inability to send to the command at all. ! > Use [`PQerrorMessage`](../proc/pqerrormessage.html) to get more information about such errors. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQPREPARE) type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName character ( * ), intent ( in ) :: query integer ( int32 ), intent ( in ) :: nParams integer ( int32 ), intent ( in ) :: paramTypes (:) type ( c_ptr ) :: res type ( uint32 ), allocatable :: u_paramTypes (:) integer :: i , siz siz = size ( paramTypes , dim = 1 ) allocate ( u_paramTypes ( siz )) do i = 1 , siz u_paramTypes ( i ) = paramTypes ( i ) end do res = PQprepare_back ( conn , stmtName , query , nParams , u_paramTypes ) end function PQprepare_int32 function PQprepare_int64 ( conn , stmtName , query , nParams , paramTypes ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned implicit none !*> Submits a request to create a prepared statement with the given parameters, and waits for completion. !*> `PQprepare` creates a prepared statement for later execution with `PQexecPrepared`. ! > This feature allows commands to be executed repeatedly without being parsed and ! > planned each time; see [PREPARE](https://www.postgresql.org/docs/current/sql-prepare.html) for details. !*> The function create a prepared statement named `stmtName` from the `query` string, which ! > must contain a single SQL command. `stmtName` can be `\"\"` to create an unnamed statement, ! > in which case any pre-existing unnamed statement is automatically replaced; otherwise it is ! > an error if the statement name is already defined in the current session. If any parameters are used, ! > they are referred to in the as `$1`, `$2`, etc. `nParams` is the number of parameters for which types ! > are pre-specified in the array `paramTypes`. ! > `paramTypes` specifies, by OID, the data types to be assigned to the parameter symbols. ! > If any particuler element in the `paramTypes` array is zero, the server assigns a data type to the ! > parameter symbol in the same way it would do for an untyped literal string. ! > Also, the query can use parameter symbols with the numbers higher than `nParams`; data types will ! > be inferred for these symbols as well. ! (See [PQdescribePrepared](../proc/pqdescribeprepared.html)) for a means to find out what data types were inffered.) !*> As with [`PQexec`](../proc/pqexec.html), the result is normally a `PGresult` object whose contents indicate server-side ! > success or failure. A null result indicates out-of-memory or inability to send to the command at all. ! > Use [`PQerrorMessage`](../proc/pqerrormessage.html) to get more information about such errors. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQPREPARE) type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName character ( * ), intent ( in ) :: query integer ( int32 ), intent ( in ) :: nParams integer ( int64 ), intent ( in ) :: paramTypes (:) type ( c_ptr ) :: res type ( uint32 ), allocatable :: u_paramTypes (:) integer :: i , siz siz = size ( paramTypes , dim = 1 ) allocate ( u_paramTypes ( siz )) do i = 1 , siz u_paramTypes ( i ) = paramTypes ( i ) end do res = PQprepare_back ( conn , stmtName , query , nParams , u_paramTypes ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQPREPARE) end function PQprepare_int64 ! --- PQprepare backend function PQprepare_back ( conn , stmtName , query , nParams , paramTypes ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned use :: character_operations_m implicit none type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName character ( * ), intent ( in ) :: query integer ( int32 ), intent ( in ) :: nParams type ( uint32 ), intent ( in ) :: paramTypes (:) type ( c_ptr ) :: res character (:, kind = c_char ), allocatable :: c_stmtName character (:, kind = c_char ), allocatable :: c_query type ( uint32 ), allocatable , target :: c_paramTypes (:) integer :: siz interface function c_PQ_prepare ( conn , stmtName , query , nParams , paramTypes ) bind ( c , name = \"PQprepare\" ) import c_ptr , uint32 , c_char , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: stmtName ( * ) character ( 1 , kind = c_char ), intent ( in ) :: query ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramTypes type ( c_ptr ) :: c_PQ_prepare end function c_PQ_prepare end interface ! paramTypes(:)をc_paramTypesに複製してその先頭アドレスをc_PQ_prepareに渡すことを目的とする。 siz = size ( paramTypes , dim = 1 ) allocate ( c_paramTypes ( siz )) c_paramTypes (:) = paramTypes (:) ! Null終端の文字列を用意する c_stmtName = trim ( adjustl ( stmtName )) // c_null_char c_query = trim ( query ) // c_null_char ! c_paramTypesのアドレスを渡す。 res = c_PQ_prepare ( conn , c_stmtName , c_query , nParams , c_loc ( c_paramTypes )) end function PQprepare_back function PQexecPrepared ( conn , stmtName , nParams , paramValues ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: character_operations_m implicit none !*> Sends a request to execute a prepared statement with given parameters, and waits for the result. ! > ! > `PQexecPrepared` is like `[[PQexecParam]]`, but the command to be executed is spcified by ! > naming a previously-prepared statement, instead of giving a query string. This feature allows ! > commands that will be used repeated to be parsed and planned just once, rather than each ! > time they are executed. The statement must have been prepared previously in the current session. ! > ! > The parameters are identical to `[[PQexecParams]]`, except that the name of a prepared statement ! > is given instead of a query string, and the `paramTypes` parameter is not present (it is not ! > needed since the prepared statement's parameter types were determined when it was created). ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQEXECPREPARED) ! Input paramters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName ! statement name integer ( int32 ), intent ( in ) :: nParams character ( * ), intent ( in ) :: paramValues (:) ! Output pointer type ( c_ptr ) :: res ! Local variables integer ( int32 ) :: resultFormat , max_len_val character (:, kind = c_char ), allocatable :: c_stmtName type ( c_ptr ) :: null_paramLengths = c_null_ptr type ( c_ptr ) :: null_paramFormats = c_null_ptr interface function c_PQ_exec_prepared ( conn , stmtName , nParams , paramValues , paramLengths , paramFormats , resultFormat ) & bind ( c , name = \"PQexecPrepared\" ) import c_ptr , c_int , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: stmtName ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramValues type ( c_ptr ), intent ( in ), value :: paramLengths type ( c_ptr ), intent ( in ), value :: paramFormats integer ( c_int ), intent ( in ), value :: resultFormat type ( c_ptr ) :: c_PQ_exec_prepared end function c_PQ_exec_prepared end interface resultFormat = 0 c_stmtName = trim ( adjustl ( stmtName )) // c_null_char if ( nParams >= 1 ) then max_len_val = max_length_char_array ( paramValues ) block character ( max_len_val + 1 , kind = c_char ), allocatable , target :: c_values (:) type ( c_ptr ), allocatable , target :: ptr_values (:) call cchar_array_from_strings_no_null ( paramValues , c_values , max_len_val ) call cptr_array_from_cchar_no_null ( c_values , ptr_values ) res = c_PQ_exec_prepared ( & conn , c_stmtName , nParams , & c_loc ( ptr_values ( 1 )), & null_paramLengths , & null_paramFormats , & resultFormat & ) end block else if ( nParams == 0 ) then block type ( c_ptr ) :: null_paramValues = c_null_ptr res = c_PQ_exec_prepared ( & conn , c_stmtName , nParams , & null_paramValues , & null_paramLengths , & null_paramFormats , & resultFormat & ) end block end if end function PQexecPrepared function PQdescribePrepared ( conn , stmtName ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none !*> Submits a request to obtain information about the specified prepared statement, and waits for completion. !*> `PQdescribePrepared` allows an application to obtain information about a previously prepared statement. ! > ! > `stmtName` can be `\"\"` to reference the unnamed statement, otherwise it must be the name of an existing ! > prepared statement. On success, a `PGresult` with status `PGRES_COMMAND_OK` is returned. The `[[PQnparams]]` ! > and `[[PQparamtype]]` can be applied to this `PGresult` to obtain information about the parameters of the ! > prepared statement, and the functions `[[PQnfields]]`, `[[PQfname]]`, `[[PQftype]]` etc. provide information ! > about the result columns (if any) of the statement. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQDESCRIBEPREPARED) ! Input paramter type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName ! Output pointer type ( c_ptr ) :: res ! Local variable character (:, kind = c_char ), allocatable :: c_stmtName interface function c_PQ_describe_prepared ( conn , stmtName ) bind ( c , name = \"PQdescribePrepared\" ) import c_ptr , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: stmtName ( * ) type ( c_ptr ) :: c_PQ_describe_prepared end function c_PQ_describe_prepared end interface c_stmtName = trim ( adjustl ( stmtName )) // c_null_char res = c_PQ_describe_prepared ( conn , c_stmtName ) end function PQdescribePrepared function PQdescribePortal ( conn , portalName ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none ! Input parameters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: portalName ! Output parameter type ( c_ptr ) :: res ! Local variables character (:, kind = c_char ), allocatable :: c_portalName interface function c_PQ_describe_portal ( conn , portalName ) bind ( c , name = \"PQdescribePortal\" ) import c_ptr , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: portalName ( * ) type ( c_ptr ) :: c_PQ_describe_portal end function c_PQ_describe_portal end interface c_portalName = trim ( adjustl ( portalName )) // c_null_char res = c_PQ_describe_portal ( conn , c_portalName ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQDESCRIBEPORTAL) end function PQdescribePortal function PQresultStatus ( pgresult ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding , only : c_ptr , c_int implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ) :: res interface ! Interface to PQresultStatus in interfaces/libpq/fe-exec.c: ! ! ExecStatusType PQresultStatus(const PGresult *res) ! function c_PQ_result_status ( pgresult ) bind ( c , name = 'PQresultStatus' ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ) :: res end function c_PQ_result_status end interface res = c_PQ_result_status ( pgresult ) !*> Returns the result status of the command. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQRESULTSTATUS) end function PQresultStatus function PQresStatus ( status ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none ! 入力 integer ( int32 ), intent ( in ) :: status ! 出力：文字列へのポインタ character (:), pointer :: res ! C関数の結果を代入するCポインタ型の変数 type ( c_ptr ) :: status_description ! C関数へのインターフェース interface function c_PQ_res_status ( status ) bind ( c , name = \"PQresStatus\" ) result ( res ) import c_ptr , c_int integer ( c_int ), intent ( in ), value :: status type ( c_ptr ) :: res end function end interface ! C関数を呼び出して、結果のポインタをstatus_descriptionに受け取る。 status_description = c_PQ_res_status ( status ) ! 結果のCポインタをFortranの文字列ポインタに変換する。 res => c_to_f_charpointer ( status_description ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQRESSTATUS) end function PQresStatus function PQresultErrorMessage ( pgresult ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult character (:, kind = c_char ), pointer :: res interface ! Interface to PQresultErrorMessage in interface/libpq/fe-exec.c: ! ! char *PQresultErrorMessage(const PGresult *res) ! function c_PQ_result_error_message ( res ) bind ( c , name = 'PQresultErrorMessage' ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: res type ( c_ptr ) :: c_PQ_result_error_message end function c_PQ_result_error_message end interface res => c_to_f_charpointer ( c_PQ_result_error_message ( pgresult )) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQRESULTERRORMESSAGE) end function PQresultErrorMessage function PQresultVerboseErrorMessage ( pgresult , verbosity , show_context ) result ( res ) use :: character_operations_m use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: verbosity integer ( int32 ), intent ( in ) :: show_context character (:, kind = c_char ), pointer :: res interface function c_PQ_result_verbose_error_message ( res , verbosity , show_context ) & bind ( c , name = 'PQresultVerboseErrorMessage' ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: res integer ( c_int ), intent ( in ), value :: verbosity , show_context type ( c_ptr ) :: c_PQ_result_verbose_error_message end function c_PQ_result_verbose_error_message end interface res => c_to_f_charpointer ( c_PQ_result_verbose_error_message ( pgresult , verbosity , show_context )) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQRESULTVERBOSEERRORMESSAGE) end function PQresultVerboseErrorMessage function PQresultErrorField ( pgresult , fieldcode ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: fieldcode character (:, kind = c_char ), pointer :: res interface ! Interface to PQresultErrorField in interface/libpq/fe-exec.c: ! ! char *PQresultErrorField(const PGresult *res) ! function c_PQ_result_error_field ( res , fieldcode ) bind ( c , name = 'PQresultErrorField' ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: res integer ( c_int ), intent ( in ), value :: fieldcode type ( c_ptr ) :: c_PQ_result_error_field end function c_PQ_result_error_field end interface res => c_to_f_charpointer ( c_PQ_result_error_field ( pgresult , fieldcode )) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQRESULTERRORFIELD) end function PQresultErrorField !-- Delete a PGresult subroutine PQclear ( res ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: res interface ! Interface to PQclear in interface/libpq/fe-exec.c: ! ! void PQclear(PGresult *res) ! subroutine c_PQ_clear ( res ) bind ( c , name = 'PQclear' ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: res end subroutine c_PQ_clear end interface call c_PQ_clear ( res ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQCLEAR) end subroutine PQclear !== Retrieving Query Result Information function PQntuples ( pgresult ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ) :: res interface ! Interface to PQntuples in interface/libpq/fe-exec.c: ! ! int PQntuples(const PGresult *res) ! function c_PQ_n_tuples ( pgresult ) bind ( c , name = 'PQntuples' ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ) :: c_PQ_n_tuples end function c_PQ_n_tuples end interface res = c_PQ_n_tuples ( pgresult ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQNTUPLES) end function PQntuples function PQnfields ( pgresult ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ) :: res interface ! Interface to PQnfields in interface/libpq/fe-exec.c: ! ! int PQnfields(const PGresult *res) ! function c_PQ_n_fields ( pgresult ) bind ( c , name = 'PQnfields' ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ) :: c_PQ_n_fields end function c_PQ_n_fields end interface res = c_PQ_n_fields ( pgresult ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQNFIELDS) end function PQnfields function PQfname ( pgresult , field_num ) result ( res ) use :: character_operations_m use , intrinsic :: iso_fortran_env , only : int32 use , intrinsic :: iso_c_binding , only : c_ptr , c_int , c_char implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: field_num character (:, kind = c_char ), pointer :: res interface ! Interface to PQfname in src/interface/libpq/fe-exec.c: ! ! char *PQfname(const PGresult *res, int field_num) function c_PQ_field_name ( pgresult , c_field_num ) bind ( c , name = 'PQfname' ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: c_field_num type ( c_ptr ) :: c_PQ_field_name end function c_PQ_field_name end interface res => c_to_f_charpointer ( c_PQ_field_name ( pgresult , field_num )) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFNAME) end function PQfname function PQfnumber ( pgresult , column_name ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult character ( * ), intent ( in ) :: column_name character (:, kind = c_char ), allocatable :: c_column_name integer :: PQfnumber interface function c_PQ_field_number ( pgresult , c_name ) bind ( c , name = 'PQfnumber' ) & result ( res ) import c_ptr , c_int , c_char implicit none type ( c_ptr ), intent ( in ), value :: pgresult character ( 1 , kind = c_char ), intent ( in ) :: c_name ( * ) integer ( c_int ) :: res end function c_PQ_field_number end interface c_column_name = trim ( adjustl ( column_name )) // c_null_char PQfnumber = c_PQ_field_number ( pgresult , c_column_name ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFNUMBER) end function PQfnumber function PQftable ( pgresult , column_number ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: unsigned ! 入力 type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: column_number ! 出力結果 integer ( int64 ) :: res ! カラムの属するテーブルのOidを格納する変数を宣言する。 type ( uint32 ) :: oid ! C関数 PQftableへのインターフェースを定義する。 interface function c_PQ_field_table ( pgresult , column_number ) bind ( c , name = \"PQftable\" ) import uint32 , c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult ! PostgreSQLの結果オブジェクト integer ( c_int ), intent ( in ), value :: column_number ! カラム番号 type ( uint32 ) :: c_PQ_field_table ! 戻り値は符号なし整数型 end function end interface ! C関数を呼び出して、Oidを取得する。 oid = c_PQ_field_table ( pgresult , column_number ) ! カラムのOidを整数型に変換して結果に格納する。 res = int ( oid ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFTABLE) end function PQftable function PQftablecol ( pgresult , column_number ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: column_number integer ( int32 ) :: res interface function c_PQ_field_table_column ( pgresult , column_number ) & bind ( c , name = \"PQftablecol\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: column_number integer ( c_int ) :: res end function c_PQ_field_table_column end interface res = c_PQ_field_table_column ( pgresult , column_number ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFTABLECOL) end function PQftablecol function PQfformat ( pgresult , column_number ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: column_number integer ( int32 ) :: res interface function c_PQ_field_format ( pgresult , column_number ) & bind ( c , name = \"PQfformat\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: column_number integer ( c_int ) :: res end function c_PQ_field_format end interface res = c_PQ_field_format ( pgresult , column_number ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFFORMAT) end function PQfformat function PQftype ( pgresult , column_number ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: unsigned ! 入力 type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: column_number ! 出力結果 integer ( int64 ) :: res ! カラムに関連したデータ型を返す。返される整数はその型の内部的なOID番号である。 type ( uint32 ) :: oid interface function c_PQ_field_type ( pgresult , column_number ) bind ( c , name = \"PQftype\" ) import uint32 , c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: column_number type ( uint32 ) :: c_PQ_field_type end function c_PQ_field_type end interface ! C関数を呼び出して、Oidを取得する。 oid = c_PQ_field_type ( pgresult , column_number ) ! カラムのOidを64ビット整数型に変換して結果を格納する。 res = int ( oid ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFTYPE) end function PQftype function PQfmod ( pgresult , column_number ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: column_number integer ( int32 ) :: res interface function c_PQ_field_modifier ( pgresult , column_number ) & bind ( c , name = \"PQfmod\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: column_number integer ( c_int ) :: res end function c_PQ_field_modifier end interface res = c_PQ_field_modifier ( pgresult , column_number ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFMOD) end function PQfmod function PQfsize ( pgresult , column_number ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: column_number integer ( int32 ) :: res interface function c_PQ_field_size ( pgresult , column_number ) & bind ( c , name = \"PQfsize\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: column_number integer ( c_int ) :: res end function c_PQ_field_size end interface res = c_PQ_field_size ( pgresult , column_number ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQFSIZE) end function PQfsize function PQbinaryTuples ( pgresult ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ) :: res logical :: PQbinaryTuples interface function c_PQ_binary_tuples ( pgresult ) & bind ( c , name = \"PQbinaryTuples\" ) result ( res ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ) :: res end function c_PQ_binary_tuples end interface res = c_PQ_binary_tuples ( pgresult ) if ( res == 1 ) then PQbinaryTuples = . true . else PQbinaryTuples = . false . end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQBINARYTUPLES) end function PQbinaryTuples function PQgetvalue ( pgresult , tuple_num , field_num ) use :: character_operations_m use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( c_int ), intent ( in ) :: tuple_num , field_num character (:, c_char ), pointer :: PQgetvalue interface ! Interface to PQgetvalue in interface/libpq/fe-exec.c: ! ! char *PQgetvalue(const PGresult *res, int tup_num, int field_num) ! function c_PQ_get_value ( res , tup_num , field_num ) & bind ( c , name = 'PQgetvalue' ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: res integer ( c_int ), intent ( in ), value :: tup_num , field_num type ( c_ptr ) :: c_PQ_get_value end function c_PQ_get_value end interface ! PQgetvalue => & c_to_f_charpointer ( & c_PQ_get_value ( pgresult , tuple_num , field_num ) & ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQGETVALUE) end function PQgetvalue function PQgetisnull ( pgresult , row_number , column_number ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: row_number , column_number logical :: PQgetisnull interface function c_PQ_get_is_null ( res , row_number , column_number ) bind ( c , name = \"PQgetisnull\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: res integer ( c_int ), intent ( in ), value :: row_number integer ( c_int ), intent ( in ), value :: column_number integer ( c_int ) :: c_PQ_get_is_null end function c_PQ_get_is_null end interface block integer :: func_result func_result = c_PQ_get_is_null ( pgresult , row_number , column_number ) PQgetisnull = . false . if ( func_result == 0 ) then PQgetisnull = . false . else if ( func_result == 1 ) then PQgetisnull = . true . end if end block !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQGETISNULL) end function PQgetisnull function PQgetlength ( pgresult ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ) :: PQgetlength interface function c_PQ_get_length ( pgresult ) bind ( c , name = \"PQgetlength\" ) import c_int , c_ptr implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ) :: c_PQ_get_length end function c_PQ_get_length end interface PQgetlength = c_PQ_get_length ( pgresult ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQGETLENGTH) end function PQgetlength function PQnparams ( pgresult ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ) :: PQnparams interface function c_PQ_nparams ( pgresult ) bind ( c , name = \"PQnparams\" ) import c_int , c_ptr implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ) :: c_PQ_nparams end function end interface PQnparams = c_PQ_nparams ( pgresult ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQNPARAMS) end function PQnparams function PQparamtype ( pgresult , param_number ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned type ( c_ptr ), intent ( in ) :: pgresult integer ( int32 ), intent ( in ) :: param_number integer ( int64 ) :: res type ( uint32 ) :: oid interface function c_PQ_parameter_type ( pgresult , param_number ) bind ( c , name = \"PQparamtype\" ) result ( res ) import uint32 , c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: pgresult integer ( c_int ), intent ( in ), value :: param_number type ( uint32 ) :: res end function c_PQ_parameter_type end interface oid = c_PQ_parameter_type ( pgresult , param_number ) res = int ( oid ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQPARAMTYPE) end function PQparamtype !== Retrieving Other Result Information function PQcmdStatus ( pgresult ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: pgresult character (:), allocatable , target , save :: str character (:), pointer :: res interface function c_PQ_command_status ( pgresult ) bind ( c , name = \"PQcmdStatus\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: pgresult type ( c_ptr ) :: c_PQ_command_status end function c_PQ_command_status end interface call c_char_to_f_string ( c_PQ_command_status ( pgresult ), str ) res => str !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQCMDSTATUS) end function PQcmdStatus function PQcmdTuples ( pgresult ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none ! Input parameters type ( c_ptr ), intent ( in ) :: pgresult ! Output parameters character (:), pointer :: res ! ローカル変数の宣言 character (:), allocatable , target , save :: str type ( c_ptr ), save :: cptr interface function c_PQ_command_tuples ( pgresult ) bind ( c , name = \"PQcmdTuples\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: pgresult type ( c_ptr ) :: c_PQ_command_tuples end function c_PQ_command_tuples end interface cptr = c_PQ_command_tuples ( pgresult ) call c_char_to_f_string ( cptr , str ) res => str !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQCMDTUPLES) end function PQcmdTuples function PQoidValue ( pgresult ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: unsigned type ( c_ptr ), intent ( in ) :: pgresult integer ( int64 ) :: res interface function c_PQ_oid_value ( pgresult ) bind ( c , name = \"PQoidValue\" ) import c_ptr , uint32 implicit none type ( c_ptr ), intent ( in ), value :: pgresult type ( uint32 ) :: c_PQ_oid_value end function c_PQ_oid_value end interface res = int ( c_PQ_oid_value ( pgresult )) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQOIDVALUE) end function PQoidValue !== Escaping Strings for Inclusion in SQL Commands function PQescapeLiteral ( conn , str , length , errmsg ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env ! Input parameters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: str integer ( c_size_t ), intent ( in ) :: length character ( * ), intent ( inout ), optional :: errmsg ! Output variable character (:), pointer :: res ! Declare local variables integer ( c_size_t ) :: len ! Actual length of the input string character (:, kind = c_char ), allocatable :: c_str ! C-style string character (:), allocatable , target , save :: result_string ! Target for the result string type ( c_ptr ) :: cptr ! Pointer to the result from the C func. ! Define an interface for the C func. interface function c_PQ_escape_literal ( conn , str , length ) bind ( c , name = \"PQescapeLiteral\" ) import c_ptr , c_size_t , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: str ( * ) integer ( c_size_t ), intent ( in ), value :: length type ( c_ptr ) :: c_PQ_escape_literal end function c_PQ_escape_literal end interface ! Initialize the result pointer variable res => null () ! Remove trailing spaces from the input string and assign it to c_str. ! Zero-type termination in not required for PQescapeLiteral. ! 引数の末尾の空白を除去して、c_strに代入する。PQescapeLiteralに限ってはゼロバイト終端は不要である。 c_str = trim ( str ) ! Get the actual length of the string ! 実際の文字列の長さをローカル変数に取得する。 len = len_trim ( str ) ! If the given length 'length' is too small, write a warging to 'errmsg'. ! 与えられた長さlengthが小さすぎる場合、errmsgに警告を書き込む。 if ( length < len ) then if ( present ( errmsg )) then write ( errmsg , * ) \"Warning: the length is too small for the string.\" end if end if ! Call the C func. and assign the result's char ponter to 'cptr' ! C関数を呼び出し、結果のcharポインタをcptrに代入する。 cptr = c_PQ_escape_literal ( conn , c_str , length ) ! if 'cptr' is a Null pointer, return to the caller. ! In this case, the C func. leaves a message in 'conn' object. ! cptrがNullポインタの場合、呼び出し元に戻る。このときconnオブジェクトにメッセージを残す。 if (. not . c_associated ( cptr )) return ! Store the result of the C func. in 'result_string' ! C関数の結果を文字列result_stringに格納する。 call c_char_to_f_string ( cptr , result_string ) ! Associate the return value pointer. ! 戻り値のポインタを関連付ける。 res => result_string ! Free the memory allocated in C. ! Cで割り付けられたメモリを解放する。 call PQfreemem ( cptr ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQESCAPELITERAL) end function PQescapeLiteral ! この関数の構造は上のPQescapeLiteralとほとんど同じなので、それに含まれるコメントも参照されたい ! The structure of this function closely resembles that of the `PQescapeLiteral`, ! and the comments included in it should also be referenced. function PQescapeIdentifier ( conn , str , length , errmsg ) result ( res ) use :: character_operations_m use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env ! Input parameters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: str integer ( c_size_t ), intent ( in ) :: length character ( * ), intent ( inout ), optional :: errmsg ! Output variable character (:), pointer :: res ! Declare local variable integer ( c_size_t ) :: len character (:, kind = c_char ), allocatable :: c_str character (:), allocatable , target , save :: result_string type ( c_ptr ) :: cptr ! Define an interface for the C func. interface function c_PQ_escape_identifier ( conn , str , length ) bind ( c , name = \"PQescapeIdentifier\" ) import c_ptr , c_size_t , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: str ( * ) integer ( c_size_t ), intent ( in ), value :: length type ( c_ptr ) :: c_PQ_escape_identifier end function c_PQ_escape_identifier end interface res => null () c_str = trim ( str ) len = len_trim ( str ) if ( length < len ) then if ( present ( errmsg )) then write ( errmsg , * ) \"Warning: the length is too small for the string.\" end if end if cptr = c_PQ_escape_identifier ( conn , c_str , length ) if (. not . c_associated ( cptr )) return call c_char_to_f_string ( cptr , result_string ) res => result_string call PQfreemem ( cptr ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-exec.html#LIBPQ-PQESCAPEIDENTIFIER) end function PQescapeIdentifier ! function PQescapeStringConn ! function PQescapeByteConn ! function PQunescapeBytea !=================================================================! !== Asynchronous Command Processing !|> Submits a command to the server without waiting for the result(s). ! > `1` is returned if the command was successfully dispatched and ! > `0` if not (in which case, use PQerrorMessage to get more information about the failure). ! function PQsendQuery ( conn , command ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: command integer ( int32 ) :: res character (:), allocatable :: c_command interface function c_PQ_send_query ( conn , c_command ) bind ( c , name = \"PQsendQuery\" ) import c_ptr , c_char , c_int type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: c_command ( * ) integer ( c_int ) :: c_PQ_send_query end function c_PQ_send_query end interface c_command = trim ( command ) // c_null_char res = c_PQ_send_query ( conn , c_command ) !*> After successfully calling `PQsendQuery`, call `[[PQgetResult]]` one or more times ! > to obtain the results. `PQsendQuery` cannot be called again (on the same connection) ! > until `[[PQgetResult]]` has returned a null pointer, indicating that the command is done. !*> In pipeline mode, this function is disallowed. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDQUERY) !*### Example !```Fortran !   type(c_ptr) :: conn !   type(c_ptr) :: res !   character(:), allocatable :: command !   integer :: ires ! !   conn = PQconnectdb(\"dbname=postgres\") !   (...error handling...) ! !   ires = PQsendQuery(conn, command) !   if (ires /= 1) then !      print *, PQerrorMessage(conn) !   end if ! !   res = PQgetResult(conn) ! !   do while (c_associated(res)) ! !      if (PQresultStatus(res) /= PGRES_TUPLES_OK) then !         print *, PQerrorMessage(conn) !      end if ! !      print *, PQgetvalue(res, 0, 0) !      call PQclear(res) ! !      res = PQgetResult(conn) ! !   end do !``` end function PQsendQuery ! 戻り値はinteger(4)なのでPQexecParamsとは別に実装する ! This function sends a prepared SQL query to a PostgreSQL connection asynchronously, ! separate from PQexecParams. function PQsendQueryParams_back ( conn , command , nParams , paramTypes , paramValues ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: unsigned use :: character_operations_m ! Input parameters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: command integer ( int32 ), intent ( in ) :: nParams type ( uint32 ), intent ( in ) :: paramTypes (:) character ( * ), intent ( in ) :: paramValues (:) ! Output integer integer ( int32 ) :: res ! Local variables character (:, kind = c_char ), allocatable :: c_command type ( uint32 ), allocatable , target :: c_paramTypes (:) integer ( int32 ) :: resultFormat integer ( int32 ) :: max_len_val type ( c_ptr ) :: cptr_paramTypes type ( c_ptr ) :: null_paramLengths = c_null_ptr type ( c_ptr ) :: null_paramFormats = c_null_ptr ! For nParams >= 1 interface function c_PQ_send_query_parameters ( conn , command , nParams , paramTypes , paramValues , & paramLengths , paramFormats , resultFormat ) & bind ( c , name = \"PQsendQueryParams\" ) import c_ptr , c_int , uint32 , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: command ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramTypes type ( c_ptr ), intent ( in ), value :: paramValues type ( c_ptr ), intent ( in ), value :: paramLengths type ( c_ptr ), intent ( in ), value :: paramFormats integer ( c_int ), intent ( in ), value :: resultFormat integer ( c_int ) :: c_PQ_send_query_parameters end function c_PQ_send_query_parameters end interface ! For nParams == 0 interface function c_PQ_send_query_parameters_zero ( conn , command , nParams , paramTypes , paramValues ,& paramLengths , paramFormats , resultFormat ) & bind ( c , name = \"PQsendQueryParams\" ) import c_ptr , c_int , uint32 , c_char implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: command ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramTypes type ( c_ptr ), intent ( in ), value :: paramValues type ( c_ptr ), intent ( in ), value :: paramLengths type ( c_ptr ), intent ( in ), value :: paramFormats integer ( c_int ), intent ( in ), value :: resultFormat integer ( c_int ) :: c_PQ_send_query_parameters_zero end function c_PQ_send_query_parameters_zero end interface resultFormat = 0 ! text format only for now. c_command = trim ( command ) // c_null_char if ( nParams >= 1 ) then max_len_val = max_length_char_array ( paramValues ) allocate ( c_paramTypes ( nParams )) c_paramTypes (:) = paramTypes (:) cptr_paramTypes = c_loc ( c_paramTypes ) block character ( max_len_val + 1 , kind = c_char ), allocatable , target :: c_values (:) type ( c_ptr ), allocatable :: ptr_values (:) call cchar_array_from_strings_no_null ( paramValues , c_values , max_len_val ) call cptr_array_from_cchar_no_null ( c_values , ptr_values ) res = c_PQ_send_query_parameters (& conn , c_command , nParams , & cptr_paramTypes , & ptr_values , & null_paramLengths , & null_paramFormats , & resultFormat & ) end block else if ( nParams == 0 ) then block type ( c_ptr ) :: null_paramTypes = c_null_ptr type ( c_ptr ) :: null_paramValues = c_null_ptr res = c_PQ_send_query_parameters_zero ( & conn , c_command , nParams , & null_paramTypes , & null_paramValues , & null_paramLengths , & null_paramFormats , & resultFormat & ) end block end if end function PQsendQueryParams_back !>> Submit a command and separate parameter to the server without waiting for the result(s). function PQsendQueryParams_int32 ( conn , command , nParams , paramTypes , paramValues ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: command integer ( int32 ), intent ( in ) :: nParams integer ( int32 ), intent ( in ) :: paramTypes (:) character ( * ), intent ( in ) :: paramValues (:) integer ( int32 ) :: res integer :: i , siz type ( uint32 ), allocatable :: u_paramTypes (:) siz = size ( paramTypes , dim = 1 ) allocate ( u_paramTypes ( siz )) do i = 1 , siz u_paramTypes ( i ) = paramTypes ( i ) end do res = PQsendQueryParams_back ( conn , command , nParams , u_paramTypes , paramValues ) !*> This is equivalent to [`PQsendQuery`](../proc/pqsendquery.html), except that query parameters can be specified ! > separately form the query string. ! > This function's parameters are handled identically [`PQexecParams`](../interface/pqexecparams.html). ! > Like [`PQexecParams`](../interface/pqexecparams.html), it allows only one command in the query. ! ! >  cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDQUERYPARAMS) end function PQsendQueryParams_int32 !>> Submit a command and separate parameter to the server without waiting for the result(s). function PQsendQueryParams_int64 ( conn , command , nParams , paramTypes , paramValues ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: command integer ( int32 ), intent ( in ) :: nParams integer ( int64 ), intent ( in ) :: paramTypes (:) character ( * ), intent ( in ) :: paramValues (:) integer ( int32 ) :: res integer :: i , siz type ( uint32 ), allocatable :: u_paramTypes (:) siz = size ( paramTypes , dim = 1 ) allocate ( u_paramTypes ( siz )) do i = 1 , siz u_paramTypes ( i ) = paramTypes ( i ) end do res = PQsendQueryParams_back ( conn , command , nParams , u_paramTypes , paramValues ) !*> This is equivalent to [`PQsendQuery`](../proc/pqsendquery.html), ! > except that query parameters can be specified ! > separately form the query string. ! > This function's parameters are handled identically [`PQexecParams`](../interface/pqexecparams.html). ! > Like [`PQexecParams`](../interface/pqexecparams.html), it allows only one command in the query. ! ! >  cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDQUERYPARAMS) end function PQsendQueryParams_int64 ! 戻り値はinteger(4)なのでPQprepareとは別に実装する !> This function sends a prepared SQL query to a PostgreSQL connection asynchronously, !> separate from PQprepare. ! Inputs: !  - conn: PostgreSQL connection pointer !  - stmtName: Name for prepared statement !  - query: SQL query string !  - nParams : Number of parameters in the query !  - paramTypes: Array of parameter types ! Outputs: !  - res: Result code (integer, 1 or 0) ! function PQsendPrepare_back ( conn , stmtName , query , nParams , paramTypes ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: unsigned use :: character_operations_m implicit none ! Input parameters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName character ( * ), intent ( in ) :: query integer ( int32 ), intent ( in ) :: nParams type ( uint32 ), intent ( in ) :: paramTypes (:) ! Output variable integer ( int32 ) :: res character (:, kind = c_char ), allocatable :: c_stmtName character (:, kind = c_char ), allocatable :: c_query type ( uint32 ), allocatable , target :: c_paramTypes (:) integer :: siz interface function c_PQ_send_prepare ( conn , stmtName , query , nParams , paramTypes ) bind ( c , name = \"PQsendPrepare\" ) import c_ptr , uint32 , c_char , c_int type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: stmtName ( * ) character ( 1 , kind = c_char ), intent ( in ) :: query ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramTypes integer ( c_int ) :: c_PQ_send_prepare end function c_PQ_send_prepare end interface ! paramTypes(:)をc_paramTypesに複製してその先頭アドレスをc_PQ_send_prepareに渡すことを目的とする。 siz = size ( paramTypes , dim = 1 ) allocate ( c_paramTypes ( siz )) c_paramTypes (:) = paramTypes (:) ! Null終端の文字列を用意する c_stmtName = trim ( adjustl ( stmtName )) // c_null_char c_query = trim ( query ) // c_null_char ! c_paramTypesのアドレスを渡し、戻り値は res = c_PQ_send_prepare ( conn , c_stmtName , c_query , nParams , c_loc ( c_paramTypes )) end function PQsendPrepare_back !|> Sends a request to create a prepared statement with the given parameters, without waiting for completion. ! > ! > This is an asynchronous version of `PQprepare`: ! > it returns `1` if it was able to dispatch the request, and `0` if not. ! > After a successfull call, call [`PQgetResult`](../proc/pqgetresult.html) to determine whether the server successfully created the prepared statement. ! > The function's parameters are handled identically to `PQprepare`. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDPREPARE) function PQsendPrepare_int32 ( conn , stmtName , query , nParams , paramTypes ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: unsigned implicit none type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName character ( * ), intent ( in ) :: query integer ( int32 ), intent ( in ) :: nParams integer ( int32 ), intent ( in ) :: paramTypes (:) integer ( int32 ) :: res type ( uint32 ), allocatable :: u_paramTypes (:) integer :: i , siz siz = size ( paramTypes , dim = 1 ) allocate ( u_paramTypes ( siz )) do i = 1 , siz u_paramTypes ( i ) = paramTypes ( i ) end do res = PQsendPrepare_back ( conn , stmtName , query , nParams , u_paramTypes ) end function PQsendPrepare_int32 !|> Sends a request to create a prepared statement with the given parameters, without waiting for completion. ! > ! > This is an asynchronous version of `PQprepare`: ! > it returns `1` if it was able to dispatch the request, and `0` if not. ! > After a successfull call, call [`PQgetResult`](../proc/pqgetresult.html) to determine whether the server successfully created the prepared statement. ! > The function's parameters are handled identically to `PQprepare`. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDPREPARE) function PQsendPrepare_int64 ( conn , stmtName , query , nParams , paramTypes ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env use :: unsigned implicit none type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName character ( * ), intent ( in ) :: query integer ( int32 ), intent ( in ) :: nParams integer ( int64 ), intent ( in ) :: paramTypes (:) integer ( int32 ) :: res type ( uint32 ), allocatable :: u_paramTypes (:) integer :: i , siz siz = size ( paramTypes , dim = 1 ) allocate ( u_paramTypes ( siz )) do i = 1 , siz u_paramTypes ( i ) = int ( paramTypes ( i )) end do res = PQsendPrepare_back ( conn , stmtName , query , nParams , u_paramTypes ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDPREPARE) end function PQsendPrepare_int64 function PQsendQueryPrepared_text ( conn , stmtName , nParams , paramValues ) result ( res ) use , intrinsic :: iso_fortran_env use , intrinsic :: iso_c_binding use :: character_operations_m ! Input paramters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName integer ( int32 ), intent ( in ) :: nParams character ( * ), intent ( in ) :: paramValues (:) ! Output integer integer ( int32 ) :: res ! Local variales integer ( int32 ) :: resultFormat , max_len_val character (:, kind = c_char ), allocatable :: c_stmtName type ( c_ptr ) :: null_paramLengths = c_null_ptr type ( c_ptr ) :: null_paramFormats = c_null_ptr interface function c_PQ_send_query_prepared ( conn , stmtName , nParams , paramValues , paramLengths , paramFormats , resultFormat ) & bind ( c , name = \"PQsendQueryPrepared\" ) import c_ptr , c_int , c_char type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: stmtName ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramValues type ( c_ptr ), intent ( in ), value :: paramLengths type ( c_ptr ), intent ( in ), value :: paramFormats integer ( c_int ), intent ( in ), value :: resultFormat integer ( c_int ) :: c_PQ_send_query_prepared end function c_PQ_send_query_prepared end interface interface function c_PQ_send_query_prepared_zero ( conn , stmtName , nParams , paramValues , paramLengths , paramFormats , resultFormat ) & bind ( c , name = \"PQsendQueryPrepared\" ) import c_ptr , c_int , c_char type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ), intent ( in ) :: stmtName ( * ) integer ( c_int ), intent ( in ), value :: nParams type ( c_ptr ), intent ( in ), value :: paramValues type ( c_ptr ), intent ( in ), value :: paramLengths type ( c_ptr ), intent ( in ), value :: paramFormats integer ( c_int ), intent ( in ), value :: resultFormat integer ( c_int ) :: c_PQ_send_query_prepared_zero end function c_PQ_send_query_prepared_zero end interface resultFormat = 0 res = 0 c_stmtName = trim ( adjustl ( stmtName )) // c_null_char if ( nParams >= 1 ) then max_len_val = max_length_char_array ( paramValues ) block character ( max_len_val + 1 , kind = c_char ), allocatable , target :: c_values (:) type ( c_ptr ), allocatable :: ptr_values (:) call cchar_array_from_strings_no_null ( paramValues , c_values , max_len_val ) call cptr_array_from_cchar_no_null ( c_values , ptr_values ) res = c_PQ_send_query_prepared ( & conn , c_stmtName , nParams , & ptr_values , & null_paramLengths , & null_paramFormats , & resultFormat & ) end block else if ( nParams == 0 ) then block type ( c_ptr ) :: null_paramValues = c_null_ptr res = c_PQ_send_query_prepared_zero ( & conn , c_stmtName , nParams , & null_paramValues , & null_paramLengths , & null_paramFormats , & resultFormat & ) end block end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDQUERYPREPARED) end function PQsendQueryPrepared_text function PQsendDescribePrepared ( conn , stmtName ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none ! Input paramters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: stmtName ! Output integer integer ( int32 ) :: res ! Local variable character (:, kind = c_char ), allocatable :: c_stmtName interface function c_PQ_send_describe_prepared ( conn , stmtName ) bind ( c , name = \"PQsendDescribePrepared\" ) import c_ptr , c_char , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ) :: stmtName ( * ) integer ( c_int ) :: c_PQ_send_describe_prepared end function c_PQ_send_describe_prepared end interface ! Initialize the result variable res = 1 ! Trim and left-align 'stmtName', then append a null termination character. c_stmtName = trim ( adjustl ( stmtName )) // c_null_char ! Call the C function 'PQsendDescribePrepared' with the converted stmtName. res = c_PQ_send_describe_prepared ( conn , c_stmtName ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDDESCRIBEPREPARED) end function PQsendDescribePrepared function PQsendDescribePortal ( conn , portalName ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none ! Input paramters type ( c_ptr ), intent ( in ) :: conn character ( * ), intent ( in ) :: portalName ! Output integer integer ( int32 ) :: res ! Local variable character (:, kind = c_char ), allocatable :: c_portalName interface function c_PQ_send_describe_portal ( conn , portalName ) bind ( c , name = \"PQsendDescribePortal\" ) import c_ptr , c_char , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn character ( 1 , kind = c_char ) :: portalName ( * ) integer ( c_int ) :: c_PQ_send_describe_portal end function c_PQ_send_describe_portal end interface ! Initialize the result variable res = 1 ! Trim and left-align 'portalName', then append a null termination character. c_portalName = trim ( adjustl ( portalName )) // c_null_char ! Call the C function 'PQsendDescribePortral' with the converted portralName. res = c_PQ_send_describe_portal ( conn , c_portalName ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSENDDESCRIBEPORTAL) end function PQsendDescribePortal function PQgetResult ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn type ( c_ptr ) :: res interface function c_PQ_get_result ( conn ) bind ( c , name = \"PQgetResult\" ) import c_ptr type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_get_result end function c_PQ_get_result end interface !*> Waits for the next result from a prior `[[PQsendQuery]]`, `[[PQsendQueryParams]]`, `[[PQsendPrepare]]`, ! > `[[PQsendQueryPrepared]]`, `[[PQsendDescribePrepared]]`, `[[PQsendDescribePortra]]`, or `[[PQpipelineSync]]` call, ! > and returns it.  A null pointer is returned when the command is complete and there will be no more results. !*> `PQgetResult` must be called repeatedly until it returns a null pointer, indicating that the command is done. ! > (If called when no command is active, `PQgetResult` will just return a null pointer at once.) ! > Each non-null result from `PQgetResult` should be processed using  the same `PGresult` accessor functions ! > prebiously described. Don't forget to free each result object with `PQclear` when done with it. ! > Note that `PQgetResult` will block only if a command is active and the necessary response data has not yet ! > been read by `[[PQconsumeInput]]`. !*> In pipeline mode, `PQgetResult` will return normally unless an error occurs; for any subsequent query sent ! > after the one that caused the error unit (and excluding) the next synchronization point, a special result of ! > type `PGRES_PIPELINE_ABORTED` will be returned, and a null pointer will be returned after it. ! > When the pipeline synchronization point is reached, a result of type `PGRES_PIPELINE_SYNC` will be returned. ! > The result of the next query after the synchronization point follows immediately (that is, no null pointer ! > is returned after the synchronization point). ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQGETRESULT) res = c_PQ_get_result ( conn ) end function PQgetResult !>> If input is available from the server, consume it. !>> function PQconsumeInput ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res Interface function c_PQ_consume_input ( conn ) bind ( c , name = \"PQconsumeInput\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_consume_input end function c_PQ_consume_input end interface res = c_PQ_consume_input ( conn ) !*> `PQconsumeInput` normally returns `1` indicating \"no error\", but returns `0` if there was some kind of ! > trouble (in which case `[[PQerrorMessage]]` can be consulted). Note that the result does not say whether any ! > input data was actually collected. After calling `PQconsumeInput`, the application can check `[[PQisBusy]]` ! > and/or `[[PQnotifies]]` to see if their state has changed. ! > ! > cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQCONSUMEINPUT) end function PQconsumeInput function PQisBusy ( conn ) result ( isBusy ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res logical :: isBusy interface function c_PQ_is_busy ( conn ) bind ( c , name = \"PQisBusy\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_is_busy end function c_PQ_is_busy end interface isBusy = . false . res = c_PQ_is_busy ( conn ) if ( res == 1 ) then isBusy = . true . else if ( res == 0 ) then isBusy = . false . end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQISBUSY) end function PQisBusy function PQsetnonblocking ( conn , arg ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ), intent ( in ) :: arg integer ( int32 ) :: res interface function c_PQ_set_nonblocking ( conn , arg ) bind ( c , name = \"PQsetnonblocking\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ), intent ( in ), value :: arg integer ( c_int ) :: c_PQ_set_nonblocking end function c_PQ_set_nonblocking end interface res = c_PQ_set_nonblocking ( conn , arg ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQSETNONBLOCKING) end function PQsetnonblocking function PQisnonblocking ( conn ) result ( isNonblocking ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res logical :: isNonblocking interface function c_PQ_is_nonblocking ( conn ) bind ( c , name = \"PQisnonblocking\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_is_nonblocking end function c_PQ_is_nonblocking end interface res = c_PQ_is_nonblocking ( conn ) if ( res == 1 ) then isNonblocking = . true . else if ( res == 0 ) then isNonblocking = . false . end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQISNONBLOCKING) end function PQisnonblocking function PQflush ( conn ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: PQflush interface function c_PQ_flush ( conn ) bind ( c , name = \"PQflush\" ) import c_ptr , c_int type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_flush end function c_PQ_flush end interface PQflush = c_PQ_flush ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-async.html#LIBPQ-PQFLUSH) end function PQflush !=================================================================! !== Pipeline Mode function PQpipelineStatus ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface function c_PQ_pipeline_status ( conn ) bind ( c , name = \"PQpipelineStatus\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_pipeline_status end function c_PQ_pipeline_status end interface res = c_PQ_pipeline_status ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-pipeline-mode.html#LIBPQ-PQPIPELINESTATUS) end function PQpipelineStatus function PQenterPipelineMode ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface function c_PQ_enter_pipeline_mode ( conn ) bind ( c , name = \"PQenterPipelineMode\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_enter_pipeline_mode end function c_PQ_enter_pipeline_mode end interface res = c_PQ_enter_pipeline_mode ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-pipeline-mode.html#LIBPQ-PQPIPELINEMODE) end function PQenterPipelineMode function PQexitPipelineMode ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface function c_PQ_exit_pipeline_mode ( conn ) bind ( c , name = \"PQexitPipelineMode\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_exit_pipeline_mode end function c_PQ_exit_pipeline_mode end interface res = c_PQ_exit_pipeline_mode ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-pipeline-mode.html#LIBPQ-PQEXITPIPELINEMODE) end function PQexitPipelineMode function PQpipelineSync ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface function c_PQ_pipeline_sync ( conn ) bind ( c , name = \"PQpipelineSync\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_pipeline_sync end function c_PQ_pipeline_sync end interface res = c_PQ_pipeline_sync ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-pipeline-mode.html#LIBPQ-PQPIPELINESYNC) end function PQpipelineSync function PQsendFlushRequest ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface function c_PQ_send_flush_request ( conn ) bind ( c , name = \"PQsendFlushRequest\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_send_flush_request end function c_PQ_send_flush_request end interface res = c_PQ_send_flush_request ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-pipeline-mode.html#LIBPQ-PQSENDFLUSHREQUEST) end function PQsendFlushRequest !=================================================================! !== Retrieving Query Result Row-by-Row function PQsetSingleRowMode ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ) :: res interface function c_PQ_set_single_row_mode ( conn ) bind ( c , name = \"PQsetSingleRowMode\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ) :: c_PQ_set_single_row_mode end function c_PQ_set_single_row_mode end interface res = c_PQ_set_single_row_mode ( conn ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-single-row-mode.html#LIBPQ-PQSETSINGLEROWMODE) end function PQsetSingleRowMode !=================================================================! !== Asynchronous Notification function PQnotifies ( conn ) result ( res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn type ( c_ptr ) :: res interface function c_PQ_notifies ( conn ) bind ( c , name = \"PQnotifies\" ) import implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ) :: c_PQ_notifies end function c_PQ_notifies end interface res = c_PQ_notifies ( conn ) end function PQnotifies !=================================================================! !== Functions Associated with the COPY Command ! function PQputCopyData ! function PQputCopyEnd ! function PQgetCopyData !=================================================================! !== Miscellaneous Functions subroutine PQfreemem ( cptr ) use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( in ) :: cptr interface subroutine c_PQ_free_memory ( cptr ) bind ( c , name = \"PQfreemem\" ) import c_ptr implicit none type ( c_ptr ), intent ( in ), value :: cptr end subroutine c_PQ_free_memory end interface call c_PQ_free_memory ( cptr ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQFREEMEM) end subroutine PQfreemem function PQmakeEmptyPGresult ( conn , status ) result ( res ) use :: enumerators_t use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn integer ( int32 ), intent ( in ) :: status type ( c_ptr ) :: res interface function c_PQ_make_empty_PGresult ( conn , status ) bind ( c , name = \"PQmakeEmptyPGresult\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn integer ( c_int ), intent ( in ), value :: status type ( c_ptr ) :: c_PQ_make_empty_PGresult end function end interface if ( 0 <= status . and . status <= PGRES_PIPELINE_ABORTED ) then res = c_PQ_make_empty_PGresult ( conn , status ) else res = c_null_ptr end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQMAKEEMPTYRESULT) end function PQmakeEmptyPGresult function PQcopyResult ( conn , res ) use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env implicit none type ( c_ptr ), intent ( in ) :: conn type ( c_ptr ), intent ( in ) :: res type ( c_ptr ) :: PQcopyResult interface function c_PQ_copy_result ( conn , res ) bind ( c , name = \"PQcopyResult\" ) import c_ptr , c_int implicit none type ( c_ptr ), intent ( in ), value :: conn type ( c_ptr ), intent ( in ), value :: res type ( c_ptr ) :: c_PQ_copy_result end function c_PQ_copy_result end interface PQcopyResult = c_PQ_copy_result ( conn , res ) !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQCOPYRESULT) end function PQcopyResult !> Get the threadsafety status of the current running libpq library. function PQisthreadsafe () use , intrinsic :: iso_c_binding implicit none integer :: result logical :: PQisthreadsafe interface function c_PQ_is_threadsafe () bind ( c , name = \"PQisthreadsafe\" ) import c_int implicit none integer ( c_int ) :: c_PQ_is_threadsafe end function c_PQ_is_threadsafe end interface result = c_PQ_is_threadsafe () if ( result == 1 ) then PQisthreadsafe = . true . else PQisthreadsafe = . false . end if !! cf. [PostgreSQL Documentation](https://www.postgresql.org/docs/current/libpq-threading.html#LIBPQ-PQISTHREADSAFE) end function PQisthreadsafe end module fe_exec_m","tags":"","loc":"sourcefile/fe-exec.f90.html"},{"title":"Readme – Libpq-Fortran","text":"Libpq-Fortran Libpq-Fortran is a Modern Fortran interface to the PostgreSQL libpq C library . This does not contain the libpq library; only the wrapper is included. The source of this package is available on GitHub - shinobuamasaki/libpq-fortran . Features Current Supported compilers are: GNU Compiler Collection: gfortran , Intel oneAPI Fortran Compiler ifx , Fortran Compiler Classic ifort . Supported PostgreSQL version: PostgreSQL v15.4 (libpq v5.15) Connections: Connection via DSN (data source name) Connection via PostgreSQL connection string UTF-8 client encoding Build This package is managed by Fortran Package Manager ( fpm ). The libpq is required and you may need to add the path to the directory containing libpq-fe.h to the environment variable FPM_CFLAGS . Add to fpm.toml in your project: [build] link = [ \"pq\" ] [dependencies] libpq-fortran = { git = \"https://github.com/shinobuamasaki/libpq-fortran\" } Test This package is tested on the following environments: FreeBSD (Release 13.2, gfortran v13.1.0) Gentoo Linux ( gfortran v12.3.1, ifort 2021.9.0, ifx 2023.1.0) Ubuntu 22.04 LTS ( gfortran v11.4.0) Microsoft Windows 10 ( gfortran MinGW-W64 v13.1.0) Goals Note that below does not represent the current state of this package. Libpq-Fortran aims to wrap libpq as documented in the PostgreSQL documentation, including all non-deprecated functionallity with its explicit interfaces . Non-Goals This package will not: parse SQL, emit SQL, provide an interface handling transactions or cursors, provide abstractions over common SQL patterns. Licenses libpq Source and PostgreSQL Documentation Portions Copyright © 1996-2023, The PostgreSQL Global Development Group Portions Copyright © 1994, The Regents of the University of California Permission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose, without fee, and without a written agreement is\nhereby granted, provided that the above copyright notice and this\nparagraph and the following two paragraphs appear in all copies. IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR\nDIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING\nLOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS\nDOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,\nINCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\nON AN \"AS IS\" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO\nPROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS. Everything Else The license for the remainder of this package appears in LICENSE . Acknowledgement The creation of this package was inspired by a discussion in the Fortran-jp community.","tags":"","loc":"page/index.html"},{"title":"Quickstart – Libpq-Fortran","text":"Quickstart Contents Introduction Dependencies Building Try it program demo Appendix Introduction Libpq-Fortran utilizes the interoperability features of Modern Fortran to provide access to the PostgreSQL official client library, libpq.\nAt present, the documentation of this is in progress, so for detailed usage of the functions, please refer to the PostgreSQL official documentation of libpq . In this article, we will explore the initial usage of this library. Dependencies Here, we will discuss the software required for building Libpq-Fortran. First, you will need the libpq installed on your operating system on the local machine. On Windows, it comes as an option when you install PostgreSQL using the wizard. On Ubuntu Linux, you can simply run the command sudo apt install libpq-dev . Next, you will need a Fortran compiler. Currently, the following compilers are supported: GNU Compiler Collection: gfortran Intel oneAPI Fortran Compiler ifx , Fortran Compiler Classic ifort Furthermore, Libpq-Fortran is managed through the Fortran Package Manager ( fpm ), so you will need this as well. Additionally, it has a dependency on another library developed by the author, uint-fortran , but fpm automatically handles this dependency. Finally, you will need a so-called sandbox database server on your localhost or local network. It is advisable to use a setup where data loss is acceptable for testing purposes. Consider this a warning. Building To get started with Libpq-Fortran, use the following commands: $ git clone https://github.com/ShinobuAmasaki/libpq-fortran\n$ cd libpq-fortran\n$ fpm build When executing fpm build , you may need to specify the directory containing the \"libpq-fe.h\" C header  with -I flag in the environment variable FPM_CFLAGS or using --c-flag . For example, on Ubuntu system, the location may be /usr/include/postgreslq , and then the command will be the following: $ fpm build --c-flag \"-I/usr/include/postgresql\" Try it The 'example' directory in the repository contains a program that interactively accesses a PostgreSQL server to retrieve a list of databases on that server. To run this, execute the following command with fpm run : $ fpm run demo --example\ndemo.f90 done .\ndemo done . [ 100 % ] Project compiled successfully. === INPUT Database Information === === type \"q\" for quit === Hostname: Success is indicated by the appearance of a prompt requesting input for accessing the server. Upon entering the information as follows, the connection is established, and the results are returned: === INPUT Database Information === === type \"q\" for quit === Hostname: localhost\ndbname: postgres\nuser: shinobu\npassword: xxx === END INPUT === === Query Result === tuples, fields: 3 1 === Available database names === postgres\ntemplate1\ntemplate0 Please modify the hostname, dbname, username, and password to suit your own environment. Thus, you were able to access a PostgreSQL database and output results using code written in Fortran. In the next section, we will delve into the details of the main program used. program demo Declaration statements In this section, let's take closer look at the main program used in the above demonstration. \nThe entire program can be found in the Appendix of this article or on GitHub . The declaration statements are as follows: program demo use :: libpq use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit type ( c_ptr ) :: conn , res character (:, kind = c_char ), allocatable :: command , conninfo integer :: i , port character ( 256 ) :: str , host , dbname , user , password Here, we start with the declaration use :: libpq , which plays a central role in this software. Additionally, please note the declaration use, intrinsic :: iso_c_binding . This is because the software interfaces directly with C libraries, requiring a C-style programming approach, \ninvolving passing and relaying pointers to objects as return values from functions. type(c_ptr) ::conn, res are variables used to store C pointers received when programming in this style. Executable statements Next, let's examine the execution statements. print * , '=== INPUT Database Information ===' print * , '=== type \"q\" for quit          ===' write ( stdout , '(a)' , advance = 'no' ) \"Hostname: \" read ( stdin , * ) host if ( host == 'q' ) stop port = 5432 write ( stdout , '(a)' , advance = 'no' ) \"dbname: \" read ( stdin , * ) dbname if ( dbname == 'q' ) stop write ( stdout , '(a)' , advance = 'no' ) \"user: \" read ( stdin , * ) user if ( user == 'q' ) stop write ( stdout , '(a)' , advance = 'no' ) \"password: \" read ( stdin , * ) password if ( password == 'q' ) stop print * , \"=== END INPUT ===\" write ( str , '(a, i0, a)' ) & \"host=\" // trim ( adjustl ( host )) // & \" port=\" , port , & \" dbname=\" // trim ( adjustl ( dbname )) // & \" user=\" // trim ( adjustl ( user )) // & \" password=\" // trim ( adjustl ( password )) This section is responsible for receiving input for connection information. Here user input is collected into various fixed-length string variables, processed, and finally copied into the connection information string conninfo . Furthermore, the next set of statements executes the connection to the database. conn = PQconnectdb ( conninfo ) if ( PQstatus ( conn ) /= 0 ) then print * , PQerrorMessage ( conn ) error stop end if The function PQconnectdb is called with the argument conninfo , and the result is assigned to the C pointer variable conn . This pointer serves as an identifier for the connection and is used by the user  without needing to concerned about its internal structure.\nFollowing this, the subsequent if block serves as error handling. As we move forward, the part where command statements are executed becomes apparent. query = \"select datname from pg_database;\" res = PQexec ( conn , query ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) end if Here, we first write the query into the string variable query . Then, we call the PQexec function to execute the query on the conn connection and assign the result to the C pointer variable res . The meaning of select datname from pg_database; is to retrieve a list of (in the sense of collection of tables) databases on the PostgreSQL server. Following this, the subsequent if block serves as error handling. And finally, there is the process of extracting the actual data from the res pointer. print * , \"=== Query Result===\" print '(a, i0, 2x, i0)' , 'tuples, fields: ' , PQntuples ( res ), PQnfields ( res ) print * , \"=== Available database names ===\" do i = 0 , PQntuples ( res ) - 1 print * , PQgetvalue ( res , i , 0 ) end do Here, we use the PQntuples and PQnfields functions to display the number of tuples (rows) and fields (columns) held by the res object. Then, we iterate through the tuples, extracting the value of the 0th column of the i th row as a string. It's worth noting that we are using 0-based indexing, following the conventions of C. The program written in this manner returns results such as the following: === Query Result === tuples, fields: 4 1 === Available database names === postgres\ntemplate1\ntemplate0 Success is indicated if it includes at least three of the following: postgres, template1, template0. Appendix The complete code for the program demonstrated above. program demo use :: libpq use , intrinsic :: iso_c_binding use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit type ( c_ptr ) :: conn , res character (:, kind = c_char ), allocatable :: query , conninfo integer :: i , port character ( 256 ) :: str , host , dbname , user , password print * , '=== INPUT Database Information ===' print * , '=== type \"q\" for quit          ===' write ( stdout , '(a)' , advance = 'no' ) \"Hostname: \" read ( stdin , * ) host if ( host == 'q' ) stop port = 5432 write ( stdout , '(a)' , advance = 'no' ) \"dbname: \" read ( stdin , * ) dbname if ( dbname == 'q' ) stop write ( stdout , '(a)' , advance = 'no' ) \"user: \" read ( stdin , * ) user if ( user == 'q' ) stop write ( stdout , '(a)' , advance = 'no' ) \"password: \" read ( stdin , * ) password if ( password == 'q' ) stop print * , \"=== END INPUT ===\" write ( str , '(a, i0, a)' ) & \"host=\" // trim ( adjustl ( host )) // & \" port=\" , port , & \" dbname=\" // trim ( adjustl ( dbname )) // & \" user=\" // trim ( adjustl ( user )) // & \" password=\" // trim ( adjustl ( password )) conninfo = str conn = PQconnectdb ( conninfo ) if ( PQstatus ( conn ) /= 0 ) then print * , PQerrorMessage ( conn ) error stop end if ! The query to retrieve the names of databases within a database cluster is: query = \"select datname from pg_database;\" res = PQexec ( conn , query ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then print * , PQerrorMessage ( conn ) end if print * , \"=== Query Result===\" print '(a, i0, 2x, i0)' , 'tuples, fields: ' , PQntuples ( res ), PQnfields ( res ) print * , \"=== Available database names ===\" do i = 0 , PQntuples ( res ) - 1 print * , PQgetvalue ( res , i , 0 ) end do call PQclear ( res ) call PQfinish ( conn ) end program demo","tags":"","loc":"page/Quickstart.html"},{"title":"Examples – Libpq-Fortran","text":"Example Programs These examples and others can be found in the directory example/ in the source repository. Example Program 1 Example Program 2","tags":"","loc":"page/Examples/index.html"},{"title":"Example Program 1 – Libpq-Fortran","text":"Example Program 1 ! example/testlibpq.f90 ! ! ! Test the Fortran version of Libpq-Fortran, !     the interface for the PostgreSQL libpq library. ! ! The original is the example program 1 from the PostgreSQL official documentation. ! program main use :: libpq use , intrinsic :: iso_fortran_env , stdout => output_unit , stderr => error_unit use , intrinsic :: iso_c_binding character (:), allocatable :: conninfo type ( c_ptr ) :: conn type ( c_ptr ) :: res integer :: nFields integer :: i , j ! If the user supplies a parameter on the command line, use it as the ! conninfo string; otherwise default to setting dbname=postgres and using ! environment variables or defaults for all other connection parameters. integer ( int32 ) :: argc type :: arguments character (:), allocatable :: v end type type ( arguments ), allocatable :: arg (:) ! Number of arguments not including execution command. argc = command_argument_count () ! String array for storing execution commands and arguments. allocate ( arg ( 0 : argc )) if ( argc > 1 ) then get_argument : block integer :: n , length_nth_arg do n = 0 , argc ! get the length of the n-th argument. call get_command_argument ( number = n , length = length_nth_arg ) ! allocate a string with the same length as the n-th argument. allocate ( character ( length_nth_arg ) :: arg ( n )% v ) ! get the value of the n-th argument as a string. call get_command_argument ( number = n , value = arg ( n )% v ) end do end block get_argument conninfo = arg ( 1 )% v else conninfo = \"dbname = postgres\" end if ! Make a connection to the database. conn = PQconnectdb ( conninfo ) ! Check to see that the backend connection was successfully made. if ( PQstatus ( conn ) /= CONNECTION_OK ) then write ( stderr , * ) PQerrorMessage ( conn ) call exit_nicely ( conn ) end if ! Set always-secure search path, so malicious users can't take control. res = PQexec ( conn , \"select pg_catalog.set_config('search_path', '', false)\" ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then write ( stderr , * ) \"SET failed: \" , PQerrorMessage ( conn ) call PQclear ( res ) call exit_nicely ( conn ) end if ! Should PQclear type(c_ptr) result whenever it is no longer need to avoid ! memory leaks. call PQclear ( res ) ! Our test case here involve s using a cursor, for which we must be ! inside a transaction block.  We could do the whole thing with a ! PQexec() of \"select * from pg_database\", but that's too trivial ! to make a good example. ! Start a transaction block res = PQexec ( conn , \"BEGIN;\" ) if ( PQresultStatus ( res ) /= PGRES_COMMAND_OK ) then write ( stderr , * ) \"BEGIN command failed: \" , PQerrorMessage ( conn ) call PQclear ( res ) call exit_nicely ( conn ) end if call PQclear ( res ) ! Fetch rows from pg_database, the system catalog of databases. res = PQexec ( conn , \"DECLARE myportal CURSOR FOR select * from pg_database\" ) if ( PQresultStatus ( res ) /= PGRES_COMMAND_OK ) then write ( stderr , * ) \"DECLARE CURSOR failed: \" , PQerrorMessage ( conn ) call PQclear ( res ) call exit_nicely ( conn ) end if call PQclear ( res ) res = PQexec ( conn , \"FETCH ALL in myportal\" ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then write ( stderr , * ) \"FETCH ALL failed: \" , PQerrorMessage ( conn ) call PQclear ( res ) call exit_nicely ( conn ) end if ! first, print out the attribute names nFields = PQnfields ( res ) do i = 0 , nFields - 1 write ( stdout , '(16(A10, 2x))' , advance = 'no' ) PQfname ( res , i ) end do print * , '' ! next, print out the rows do i = 0 , PQntuples ( res ) - 1 do j = 0 , nFields - 1 write ( stdout , '(16(a10, 2x))' , advance = 'no' ) PQgetvalue ( res , i , j ) end do print * , '' end do call PQclear ( res ) ! close the portal ... we don't bother to check for errors ... res = PQexec ( conn , \"CLOSE myportal\" ) call PQclear ( res ) ! end the transaction res = PQexec ( conn , \"END\" ) call PQclear ( res ) ! close the connection to the database and cleanup call PQfinish ( conn ) stop contains subroutine exit_nicely ( conn ) use :: libpq use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( inout ) :: conn call PQfinish ( conn ) stop end subroutine exit_nicely end program main","tags":"","loc":"page/Examples/example-1.html"},{"title":"Example Program 2 – Libpq-Fortran","text":"Example Program 2 Main program ! example/testlibpq2.f90 ! ! Test of the asynchronous notification interface on Linux ! ! The original is the example program 2 from the PostgreSQL official documentation. ! ! Start this program, then from psql in another window do !    NOTIFY TBL2; ! Repeat four times to get this program to exit. ! ! Or, if you want to get fancy, try this: ! populate a database with the following commands ! !   CREATE SCHEMA TESTLIBPQ2; !   SET search_path = TESTLIBPQ2; !   CREATE TABLE TBL1 (i int4); !   CREATE TABLE TBL2 (i int4); !   CREATE ROLE r1 AS ON INSERT TO TBL1 DO !      (INSERT INTO TBL2 VALUES (new.i); NOTIFY TBL2); program main use :: libpq use :: unsigned use , intrinsic :: iso_fortran_env , stdout => output_unit , stderr => error_unit use , intrinsic :: iso_c_binding implicit none character (:), allocatable :: conninfo type ( c_ptr ) :: conn , res type ( c_ptr ) :: notify integer ( int32 ) :: nnotifies ! If the user supplies a parameter on the command line, use it as the ! conninfo string; otherwise default to setting dbname=postgres and using ! environment variables or defaults for all other connection parameters integer ( int32 ) :: argc type :: arguments character (:), allocatable :: v end type type ( arguments ), allocatable :: arg (:) ! for Linux type , bind ( c ) :: fd_set integer ( c_int64_t ) :: fds_bits ( 16 ) end type interface function select ( nfds , readfds , writefds , exceptfds , timeout ) bind ( c ) import c_ptr , c_int implicit none integer ( c_int ), intent ( in ), value :: nfds type ( c_ptr ), intent ( in ), value :: readfds type ( c_ptr ), intent ( in ), value :: writefds type ( c_ptr ), intent ( in ), value :: exceptfds type ( c_ptr ), intent ( in ), value :: timeout integer ( c_int ) :: select end function select end interface ! Interface for using macro FD_ZERO. interface subroutine c_FD_ZERO ( set ) bind ( c , name = \"fd_zero_wrap\" ) import fd_set implicit none type ( fd_set ), intent ( inout ) :: set end subroutine c_FD_ZERO end interface ! Interface for using macro FD_SET interface subroutine c_FD_SET ( fd , set ) bind ( c , name = \"fd_set_wrap\" ) import fd_set , c_int implicit none integer ( c_int ), intent ( in ), value :: fd type ( fd_set ), intent ( inout ) :: set end subroutine c_FD_SET end interface ! Number of arguments not including execution command. argc = command_argument_count () ! String array for storing execution commands and arguments. allocate ( arg ( 0 : argc )) if ( argc > 1 ) then get_argument : block integer :: n , length_nth_arg do n = 0 , argc ! get the length of the n-th argument. call get_command_argument ( number = n , length = length_nth_arg ) ! allocate a string with the same length as the n-th argument. allocate ( character ( length_nth_arg ) :: arg ( n )% v ) ! get the value of the n-th argument as a string. call get_command_argument ( number = n , value = arg ( n )% v ) end do end block get_argument conninfo = arg ( 1 )% v else conninfo = \"dbname = postgres\" end if ! Make a connection to the database. conn = PQconnectdb ( conninfo ) ! Check to see that the backend connection was successfully made. if ( PQstatus ( conn ) /= CONNECTION_OK ) then write ( stderr , * ) PQerrorMessage ( conn ) call exit_nicely ( conn ) end if ! Set always-secure search path, so malicious users can't take control. res = PQexec ( conn , \"select pg_catalog.set_config('search_path', '', false)\" ) if ( PQresultStatus ( res ) /= PGRES_TUPLES_OK ) then write ( stderr , * ) \"SET failed: \" , PQerrorMessage ( conn ) call PQclear ( res ) call exit_nicely ( conn ) end if ! Should PQclear type(c_ptr) result whenever it is no longer need to avoid ! memory leaks. call PQclear ( res ) ! Issue LISTEN command to enable notifications from the rule's NOTIFY. res = PQexec ( conn , \"LISTEN TBL2\" ) if ( PQresultStatus ( res ) /= PGRES_COMMAND_OK ) then write ( stderr , * ) \"LISTEN command failed: \" , PQerrorMessage ( conn ) call PQclear ( res ) call exit_nicely ( conn ) end if call PQclear ( res ) ! Quit after four notifies are recieved. nnotifies = 0 do while ( nnotifies < 4 ) ! Sleep until something happens on the connection. ! We use select(2) to wait for input, but you could also use poll() or ! similar facilities. block integer :: sock integer :: res type ( fd_set ), target :: input_mask type ( pgNotify ), pointer :: fptr character ( 4 ), pointer :: str_ptr sock = PQsocket ( conn ) if ( sock < 0 ) exit ! shouldn't happen call c_FD_ZERO ( input_mask ) call c_FD_SET ( sock , input_mask ) if ( select ( sock + 1 , c_loc ( input_mask ), c_null_ptr , c_null_ptr , c_null_ptr ) < 0 ) then write ( stderr , * ) \"select() faild.\" call exit_nicely ( conn ) end if print * , \"PQisBusy: \" , PQisBusy ( conn ) ! Now check for input. res = PQconsumeInput ( conn ) print * , \"PQconsumeInput\" print * , \"PQisBusy: \" , PQisBusy ( conn ) notify = PQnotifies ( conn ) do while ( c_associated ( notify )) call c_f_pointer ( notify , fptr ) call c_f_pointer ( fptr % relname , str_ptr ) write ( stderr , \"(3a, i0)\" ) 'ASYNC NOTIFY of ' , str_ptr , & ' received from backend PID ' , fptr % be_pid call PQfreemem ( notify ) nnotifies = nnotifies + 1 res = PQconsumeInput ( conn ) notify = PQnotifies ( conn ) end do end block end do write ( stderr , * ) \"Done.\" ! close the connection to the database and cleanup call PQfinish ( conn ) stop contains subroutine exit_nicely ( conn ) use :: libpq use , intrinsic :: iso_c_binding implicit none type ( c_ptr ), intent ( inout ) :: conn call PQfinish ( conn ) stop end subroutine exit_nicely end program main C subroutines #include <sys/select.h> void fd_zero_wrap ( fd_set * set ) { FD_ZERO ( set ); return ; } void fd_set_wrap ( int fd , fd_set * set ) { FD_SET ( fd , set ); return ; }","tags":"","loc":"page/Examples/example-2.html"},{"title":"Coding Conventions – Libpq-Fortran","text":"Coding Conventions Indentation All code contained herein shall be written with a three-space indentation. Naming All Fortran code contained herein shall be written lowercase, except for maintaining original case for C functions and all associated Fortran codes.","tags":"","loc":"page/Convention.html"}]}